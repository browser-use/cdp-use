"""
Command generator for CDP protocol commands.

Generates Python function signatures and parameter types for CDP commands.
"""

import re
from typing import Any, Dict, List, Optional, Union


class CommandGenerator:
    """Generates Python function signatures and parameter types for CDP commands."""

    def __init__(self):
        self.imports = set()
        self.generated_commands = set()
        self.type_checking_imports = set()
        self.all_enums = set()

    def generate_commands(self, domain: Dict[str, Any]) -> str:
        """Generate commands.py content for a domain."""
        self.imports.clear()
        self.generated_commands.clear()
        self.type_checking_imports.clear()

        domain_name = domain["domain"]
        commands = domain.get("commands", [])

        # Always add basic imports
        self.imports.add("from typing import Any, Dict, List, Optional, Union")
        self.imports.add(
            "from typing_extensions import TypedDict, NotRequired"
        )  # For parameter types
        self.imports.add("from pydantic import BaseModel")  # For return types

        # Start with auto-generated header
        content = """# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""
        content += f'"""CDP {domain_name} Domain Commands"""\n\n'

        # Generate command definitions
        command_definitions = []
        for command in commands:
            command_content = self.generate_command_definition(command, domain_name)
            if command_content:
                command_definitions.append(command_content)

        # Add imports
        if self.imports:
            content += "\n".join(sorted(self.imports))
            content += "\n\n"

        # Add TYPE_CHECKING imports if any
        if self.type_checking_imports:
            content += "from typing import TYPE_CHECKING\n\n"
            content += "if TYPE_CHECKING:\n"
            for imp in sorted(self.type_checking_imports):
                content += f"    {imp}\n"
            content += "\n"

        # Add command definitions
        if command_definitions:
            content += "\n\n\n".join(command_definitions)

            # Add model_rebuild() calls for Pydantic return models
            rebuild_calls = []
            for command in commands:
                returns = command.get("returns", [])
                if returns:
                    command_name = command["name"]
                    class_name = self.to_class_name(command_name) + "Returns"
                    rebuild_calls.append(f"{class_name}.model_rebuild()")

            if rebuild_calls:
                content += (
                    "\n\n# Rebuild Pydantic models to resolve forward references\n"
                )
                content += "def _rebuild_models_when_ready():\n"
                content += "    try:\n"
                for imp in sorted(self.type_checking_imports):
                    content += f"        {imp}\n"
                content += "        # Rebuild models now that imports are available\n"
                for call in rebuild_calls:
                    content += f"        {call}\n"
                content += "    except ImportError:\n"
                content += "        pass  # Will be rebuilt later\n"
                content += "\n_rebuild_models_when_ready()\n"
        else:
            content += "# No commands defined for this domain"

        return content

    def generate_command_definition(
        self, command: Dict[str, Any], domain_name: str
    ) -> str:
        """Generate a single command definition."""
        command_name = command["name"]
        command.get("description", "")
        parameters = command.get("parameters", [])
        returns = command.get("returns", [])

        # Generate parameter type
        param_type_content = self.generate_parameter_type(
            command_name, parameters, domain_name
        )

        # Generate return type
        return_type_content = self.generate_return_type(
            command_name, returns, domain_name
        )

        # Combine both
        content = ""
        if param_type_content:
            content += param_type_content + "\n\n"
        if return_type_content:
            content += return_type_content

        return content

    def generate_parameter_type(
        self, command_name: str, parameters: List[Dict[str, Any]], domain_name: str
    ) -> str:
        """Generate parameter TypedDict for a command."""
        if not parameters:
            return ""

        class_name = self.to_class_name(command_name) + "Parameters"

        content = f"class {class_name}(TypedDict"

        # Check if all parameters are optional
        required_params = []
        optional_params = []

        for param in parameters:
            if param.get("optional", False):
                optional_params.append(param)
            else:
                required_params.append(param)

        # Use total=False if all parameters are optional
        if optional_params and not required_params:
            content += ", total=False"

        content += "):\n"

        if not parameters:
            content += "    pass\n"
        else:
            for param in parameters:
                param_name = param["name"]
                param_type = self.resolve_parameter_type(param, domain_name)
                param_desc = param.get("description", "")

                # Handle optional parameters
                if param.get("optional", False) and required_params:
                    param_type = f"NotRequired[{param_type}]"

                content += f'    {param_name}: "{param_type}"\n'

        self.generated_commands.add(class_name)
        return content

    def generate_return_type(
        self, command_name: str, returns: List[Dict[str, Any]], domain_name: str
    ) -> str:
        """Generate return TypedDict for a command."""
        if not returns:
            return ""

        class_name = self.to_class_name(command_name) + "Returns"

        content = f"class {class_name}(BaseModel):\n"

        if not returns:
            content += "    pass\n"
        else:
            # Separate required and optional returns
            required_returns = [r for r in returns if not r.get("optional", False)]
            optional_returns = [r for r in returns if r.get("optional", False)]

            # Required first
            for return_param in required_returns:
                return_name = return_param["name"]
                return_type = self.resolve_parameter_type(return_param, domain_name)
                return_desc = return_param.get("description", "")

                content += f'    {return_name}: "{return_type}"\n'

            # Optional returns
            for return_param in optional_returns:
                return_name = return_param["name"]
                return_type = self.resolve_parameter_type(return_param, domain_name)
                return_desc = return_param.get("description", "")

                content += f'    {return_name}: "Optional[{return_type}]" = None\n'

        self.generated_commands.add(class_name)
        return content

    def resolve_parameter_type(self, param: Dict[str, Any], domain_name: str) -> str:
        """Resolve the Python type for a parameter."""
        # Check for $ref first
        if "$ref" in param:
            return self.resolve_type_reference(param, domain_name)

        # Handle inline types
        param_type = param.get("type", "any")

        if param_type == "array":
            items = param.get("items", {})
            item_type = self.resolve_type_reference(items, domain_name)
            return f"List[{item_type}]"

        if param_type == "object":
            return "Dict[str, Any]"

        return self.map_primitive_type(param_type)

    def resolve_type_reference(
        self, type_ref: Dict[str, Any], current_domain: str = ""
    ) -> str:
        """Resolve a type reference ($ref)."""
        if "$ref" in type_ref:
            ref = type_ref["$ref"]
            type_name = ""

            # Handle cross-domain references
            if "." in ref:
                # Format: DomainName.TypeName
                parts = ref.split(".")
                domain_ref = parts[0].lower()
                type_name = parts[1]
                # Add import for cross-domain reference in TYPE_CHECKING
                self.type_checking_imports.add(
                    f"from ..{domain_ref}.types import {type_name}"
                )
            else:
                type_name = ref
                # Same domain reference - always import from types module in commands
                self.type_checking_imports.add(f"from .types import {ref}")

            fqn = ref if "." in ref else f"{current_domain}.{ref}"
            if fqn in self.all_enums:
                return f"Union[{type_name}, str]"

            return type_name

        # Handle inline type definitions
        if "type" in type_ref:
            return self.map_primitive_type(type_ref["type"])

        return "Any"

    def map_primitive_type(self, cdp_type: str) -> str:
        """Map CDP primitive types to Python types."""
        mapping = {
            "string": "str",
            "integer": "int",
            "number": "float",
            "boolean": "bool",
            "any": "Any",
            "object": "Dict[str, Any]",
        }
        return mapping.get(cdp_type, "Any")

    def to_class_name(self, name: str) -> str:
        """Convert a command name to a class name."""
        # Convert camelCase to PascalCase
        if name:
            return name[0].upper() + name[1:]
        return name

    def sanitize_name(self, name: str) -> str:
        """Sanitize a name to be a valid Python identifier."""
        # Replace invalid characters
        name = re.sub(r"[^a-zA-Z0-9_]", "_", name)

        # Ensure it starts with a letter or underscore
        if name and name[0].isdigit():
            name = "_" + name

        return name
