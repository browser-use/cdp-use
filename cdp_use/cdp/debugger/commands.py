# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Debugger Domain Commands"""

from pydantic import BaseModel
from typing import List, Optional
from typing_extensions import TypedDict, NotRequired

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..runtime.types import CallArgument
    from ..runtime.types import ExceptionDetails
    from ..runtime.types import RemoteObject
    from ..runtime.types import RemoteObjectId
    from ..runtime.types import ScriptId
    from ..runtime.types import StackTrace
    from ..runtime.types import StackTraceId
    from ..runtime.types import TimeDelta
    from ..runtime.types import UniqueDebuggerId
    from .types import BreakLocation
    from .types import BreakpointId
    from .types import CallFrame
    from .types import CallFrameId
    from .types import Location
    from .types import LocationRange
    from .types import ScriptPosition
    from .types import SearchMatch
    from .types import WasmDisassemblyChunk

class ContinueToLocationParameters(TypedDict):
    location: "Location"
    targetCallFrames: "NotRequired[str]"





class EnableParameters(TypedDict, total=False):
    maxScriptsCacheSize: "float"


class EnableReturns(BaseModel):
    debuggerId: "UniqueDebuggerId"



class EvaluateOnCallFrameParameters(TypedDict):
    callFrameId: "CallFrameId"
    expression: "str"
    objectGroup: "NotRequired[str]"
    includeCommandLineAPI: "NotRequired[bool]"
    silent: "NotRequired[bool]"
    returnByValue: "NotRequired[bool]"
    generatePreview: "NotRequired[bool]"
    throwOnSideEffect: "NotRequired[bool]"
    timeout: "NotRequired[TimeDelta]"


class EvaluateOnCallFrameReturns(BaseModel):
    result: "RemoteObject"
    exceptionDetails: "Optional[ExceptionDetails]" = None



class GetPossibleBreakpointsParameters(TypedDict):
    start: "Location"
    end: "NotRequired[Location]"
    restrictToFunction: "NotRequired[bool]"


class GetPossibleBreakpointsReturns(BaseModel):
    locations: "List[BreakLocation]"



class GetScriptSourceParameters(TypedDict):
    scriptId: "ScriptId"


class GetScriptSourceReturns(BaseModel):
    scriptSource: "str"
    bytecode: "Optional[str]" = None



class DisassembleWasmModuleParameters(TypedDict):
    scriptId: "ScriptId"


class DisassembleWasmModuleReturns(BaseModel):
    totalNumberOfLines: "int"
    functionBodyOffsets: "List[int]"
    chunk: "WasmDisassemblyChunk"
    streamId: "Optional[str]" = None



class NextWasmDisassemblyChunkParameters(TypedDict):
    streamId: "str"


class NextWasmDisassemblyChunkReturns(BaseModel):
    chunk: "WasmDisassemblyChunk"



class GetWasmBytecodeParameters(TypedDict):
    scriptId: "ScriptId"


class GetWasmBytecodeReturns(BaseModel):
    bytecode: "str"



class GetStackTraceParameters(TypedDict):
    stackTraceId: "StackTraceId"


class GetStackTraceReturns(BaseModel):
    stackTrace: "StackTrace"



class PauseOnAsyncCallParameters(TypedDict):
    parentStackTraceId: "StackTraceId"





class RemoveBreakpointParameters(TypedDict):
    breakpointId: "BreakpointId"





class RestartFrameParameters(TypedDict):
    callFrameId: "CallFrameId"
    mode: "NotRequired[str]"


class RestartFrameReturns(BaseModel):
    callFrames: "List[CallFrame]"
    asyncStackTrace: "Optional[StackTrace]" = None
    asyncStackTraceId: "Optional[StackTraceId]" = None



class ResumeParameters(TypedDict, total=False):
    terminateOnResume: "bool"





class SearchInContentParameters(TypedDict):
    scriptId: "ScriptId"
    query: "str"
    caseSensitive: "NotRequired[bool]"
    isRegex: "NotRequired[bool]"


class SearchInContentReturns(BaseModel):
    result: "List[SearchMatch]"



class SetAsyncCallStackDepthParameters(TypedDict):
    maxDepth: "int"





class SetBlackboxExecutionContextsParameters(TypedDict):
    uniqueIds: "List[str]"





class SetBlackboxPatternsParameters(TypedDict):
    patterns: "List[str]"
    skipAnonymous: "NotRequired[bool]"





class SetBlackboxedRangesParameters(TypedDict):
    scriptId: "ScriptId"
    positions: "List[ScriptPosition]"





class SetBreakpointParameters(TypedDict):
    location: "Location"
    condition: "NotRequired[str]"


class SetBreakpointReturns(BaseModel):
    breakpointId: "BreakpointId"
    actualLocation: "Location"



class SetInstrumentationBreakpointParameters(TypedDict):
    instrumentation: "str"


class SetInstrumentationBreakpointReturns(BaseModel):
    breakpointId: "BreakpointId"



class SetBreakpointByUrlParameters(TypedDict):
    lineNumber: "int"
    url: "NotRequired[str]"
    urlRegex: "NotRequired[str]"
    scriptHash: "NotRequired[str]"
    columnNumber: "NotRequired[int]"
    condition: "NotRequired[str]"


class SetBreakpointByUrlReturns(BaseModel):
    breakpointId: "BreakpointId"
    locations: "List[Location]"



class SetBreakpointOnFunctionCallParameters(TypedDict):
    objectId: "RemoteObjectId"
    condition: "NotRequired[str]"


class SetBreakpointOnFunctionCallReturns(BaseModel):
    breakpointId: "BreakpointId"



class SetBreakpointsActiveParameters(TypedDict):
    active: "bool"





class SetPauseOnExceptionsParameters(TypedDict):
    state: "str"





class SetReturnValueParameters(TypedDict):
    newValue: "CallArgument"





class SetScriptSourceParameters(TypedDict):
    scriptId: "ScriptId"
    scriptSource: "str"
    dryRun: "NotRequired[bool]"
    allowTopFrameEditing: "NotRequired[bool]"


class SetScriptSourceReturns(BaseModel):
    status: "str"
    callFrames: "Optional[List[CallFrame]]" = None
    stackChanged: "Optional[bool]" = None
    asyncStackTrace: "Optional[StackTrace]" = None
    asyncStackTraceId: "Optional[StackTraceId]" = None
    exceptionDetails: "Optional[ExceptionDetails]" = None



class SetSkipAllPausesParameters(TypedDict):
    skip: "bool"





class SetVariableValueParameters(TypedDict):
    scopeNumber: "int"
    variableName: "str"
    newValue: "CallArgument"
    callFrameId: "CallFrameId"





class StepIntoParameters(TypedDict, total=False):
    breakOnAsyncCall: "bool"
    skipList: "List[LocationRange]"





class StepOverParameters(TypedDict, total=False):
    skipList: "List[LocationRange]"




# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..runtime.types import CallArgument
        from ..runtime.types import ExceptionDetails
        from ..runtime.types import RemoteObject
        from ..runtime.types import RemoteObjectId
        from ..runtime.types import ScriptId
        from ..runtime.types import StackTrace
        from ..runtime.types import StackTraceId
        from ..runtime.types import TimeDelta
        from ..runtime.types import UniqueDebuggerId
        from .types import BreakLocation
        from .types import BreakpointId
        from .types import CallFrame
        from .types import CallFrameId
        from .types import Location
        from .types import LocationRange
        from .types import ScriptPosition
        from .types import SearchMatch
        from .types import WasmDisassemblyChunk
        # Rebuild models now that imports are available
        EnableReturns.model_rebuild()
        EvaluateOnCallFrameReturns.model_rebuild()
        GetPossibleBreakpointsReturns.model_rebuild()
        GetScriptSourceReturns.model_rebuild()
        DisassembleWasmModuleReturns.model_rebuild()
        NextWasmDisassemblyChunkReturns.model_rebuild()
        GetWasmBytecodeReturns.model_rebuild()
        GetStackTraceReturns.model_rebuild()
        RestartFrameReturns.model_rebuild()
        SearchInContentReturns.model_rebuild()
        SetBreakpointReturns.model_rebuild()
        SetInstrumentationBreakpointReturns.model_rebuild()
        SetBreakpointByUrlReturns.model_rebuild()
        SetBreakpointOnFunctionCallReturns.model_rebuild()
        SetScriptSourceReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
