# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Debugger Domain Commands"""

from pydantic import BaseModel
from typing import List, Optional
from typing_extensions import TypedDict

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..runtime.types import CallArgument
    from ..runtime.types import ExceptionDetails
    from ..runtime.types import RemoteObject
    from ..runtime.types import RemoteObjectId
    from ..runtime.types import ScriptId
    from ..runtime.types import StackTrace
    from ..runtime.types import StackTraceId
    from ..runtime.types import TimeDelta
    from ..runtime.types import UniqueDebuggerId
    from .types import BreakLocation
    from .types import BreakpointId
    from .types import CallFrame
    from .types import CallFrameId
    from .types import Location
    from .types import LocationRange
    from .types import ScriptPosition
    from .types import SearchMatch
    from .types import WasmDisassemblyChunk

class ContinueToLocationParameters(TypedDict):
    location: "Location"
    """Location to continue to."""
    targetCallFrames: "Optional[str]"





class EnableParameters(TypedDict, total=False):
    maxScriptsCacheSize: "float"
    """The maximum size in bytes of collected scripts (not referenced by other heap objects)
the debugger can hold. Puts no limit if parameter is omitted."""


class EnableReturns(BaseModel):
    debuggerId: "UniqueDebuggerId"



class EvaluateOnCallFrameParameters(TypedDict):
    callFrameId: "CallFrameId"
    """Call frame identifier to evaluate on."""
    expression: "str"
    """Expression to evaluate."""
    objectGroup: "Optional[str]"
    """String object group name to put result into (allows rapid releasing resulting object handles
using `releaseObjectGroup`)."""
    includeCommandLineAPI: "Optional[bool]"
    """Specifies whether command line API should be available to the evaluated expression, defaults
to false."""
    silent: "Optional[bool]"
    """In silent mode exceptions thrown during evaluation are not reported and do not pause
execution. Overrides `setPauseOnException` state."""
    returnByValue: "Optional[bool]"
    """Whether the result is expected to be a JSON object that should be sent by value."""
    generatePreview: "Optional[bool]"
    """Whether preview should be generated for the result."""
    throwOnSideEffect: "Optional[bool]"
    """Whether to throw an exception if side effect cannot be ruled out during evaluation."""
    timeout: "Optional[TimeDelta]"
    """Terminate execution after timing out (number of milliseconds)."""


class EvaluateOnCallFrameReturns(BaseModel):
    result: "RemoteObject"
    exceptionDetails: "Optional[ExceptionDetails]" = None



class GetPossibleBreakpointsParameters(TypedDict):
    start: "Location"
    """Start of range to search possible breakpoint locations in."""
    end: "Optional[Location]"
    """End of range to search possible breakpoint locations in (excluding). When not specified, end
of scripts is used as end of range."""
    restrictToFunction: "Optional[bool]"
    """Only consider locations which are in the same (non-nested) function as start."""


class GetPossibleBreakpointsReturns(BaseModel):
    locations: "List[BreakLocation]"



class GetScriptSourceParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the script to get source for."""


class GetScriptSourceReturns(BaseModel):
    scriptSource: "str"
    bytecode: "Optional[str]" = None



class DisassembleWasmModuleParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the script to disassemble"""


class DisassembleWasmModuleReturns(BaseModel):
    totalNumberOfLines: "int"
    functionBodyOffsets: "List[int]"
    chunk: "WasmDisassemblyChunk"
    streamId: "Optional[str]" = None



class NextWasmDisassemblyChunkParameters(TypedDict):
    streamId: "str"


class NextWasmDisassemblyChunkReturns(BaseModel):
    chunk: "WasmDisassemblyChunk"



class GetWasmBytecodeParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the Wasm script to get source for."""


class GetWasmBytecodeReturns(BaseModel):
    bytecode: "str"



class GetStackTraceParameters(TypedDict):
    stackTraceId: "StackTraceId"


class GetStackTraceReturns(BaseModel):
    stackTrace: "StackTrace"



class PauseOnAsyncCallParameters(TypedDict):
    parentStackTraceId: "StackTraceId"
    """Debugger will pause when async call with given stack trace is started."""





class RemoveBreakpointParameters(TypedDict):
    breakpointId: "BreakpointId"





class RestartFrameParameters(TypedDict):
    callFrameId: "CallFrameId"
    """Call frame identifier to evaluate on."""
    mode: "Optional[str]"
    """The `mode` parameter must be present and set to 'StepInto', otherwise
`restartFrame` will error out."""


class RestartFrameReturns(BaseModel):
    callFrames: "List[CallFrame]"
    asyncStackTrace: "Optional[StackTrace]" = None
    asyncStackTraceId: "Optional[StackTraceId]" = None



class ResumeParameters(TypedDict, total=False):
    terminateOnResume: "bool"
    """Set to true to terminate execution upon resuming execution. In contrast
to Runtime.terminateExecution, this will allows to execute further
JavaScript (i.e. via evaluation) until execution of the paused code
is actually resumed, at which point termination is triggered.
If execution is currently not paused, this parameter has no effect."""





class SearchInContentParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the script to search in."""
    query: "str"
    """String to search for."""
    caseSensitive: "Optional[bool]"
    """If true, search is case sensitive."""
    isRegex: "Optional[bool]"
    """If true, treats string parameter as regex."""


class SearchInContentReturns(BaseModel):
    result: "List[SearchMatch]"



class SetAsyncCallStackDepthParameters(TypedDict):
    maxDepth: "int"
    """Maximum depth of async call stacks. Setting to `0` will effectively disable collecting async
call stacks (default)."""





class SetBlackboxExecutionContextsParameters(TypedDict):
    uniqueIds: "List[str]"
    """Array of execution context unique ids for the debugger to ignore."""





class SetBlackboxPatternsParameters(TypedDict):
    patterns: "List[str]"
    """Array of regexps that will be used to check script url for blackbox state."""
    skipAnonymous: "Optional[bool]"
    """If true, also ignore scripts with no source url."""





class SetBlackboxedRangesParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the script."""
    positions: "List[ScriptPosition]"





class SetBreakpointParameters(TypedDict):
    location: "Location"
    """Location to set breakpoint in."""
    condition: "Optional[str]"
    """Expression to use as a breakpoint condition. When specified, debugger will only stop on the
breakpoint if this expression evaluates to true."""


class SetBreakpointReturns(BaseModel):
    breakpointId: "BreakpointId"
    actualLocation: "Location"



class SetInstrumentationBreakpointParameters(TypedDict):
    instrumentation: "str"
    """Instrumentation name."""


class SetInstrumentationBreakpointReturns(BaseModel):
    breakpointId: "BreakpointId"



class SetBreakpointByUrlParameters(TypedDict):
    lineNumber: "int"
    """Line number to set breakpoint at."""
    url: "Optional[str]"
    """URL of the resources to set breakpoint on."""
    urlRegex: "Optional[str]"
    """Regex pattern for the URLs of the resources to set breakpoints on. Either `url` or
`urlRegex` must be specified."""
    scriptHash: "Optional[str]"
    """Script hash of the resources to set breakpoint on."""
    columnNumber: "Optional[int]"
    """Offset in the line to set breakpoint at."""
    condition: "Optional[str]"
    """Expression to use as a breakpoint condition. When specified, debugger will only stop on the
breakpoint if this expression evaluates to true."""


class SetBreakpointByUrlReturns(BaseModel):
    breakpointId: "BreakpointId"
    locations: "List[Location]"



class SetBreakpointOnFunctionCallParameters(TypedDict):
    objectId: "RemoteObjectId"
    """Function object id."""
    condition: "Optional[str]"
    """Expression to use as a breakpoint condition. When specified, debugger will
stop on the breakpoint if this expression evaluates to true."""


class SetBreakpointOnFunctionCallReturns(BaseModel):
    breakpointId: "BreakpointId"



class SetBreakpointsActiveParameters(TypedDict):
    active: "bool"
    """New value for breakpoints active state."""





class SetPauseOnExceptionsParameters(TypedDict):
    state: "str"
    """Pause on exceptions mode."""





class SetReturnValueParameters(TypedDict):
    newValue: "CallArgument"
    """New return value."""





class SetScriptSourceParameters(TypedDict):
    scriptId: "ScriptId"
    """Id of the script to edit."""
    scriptSource: "str"
    """New content of the script."""
    dryRun: "Optional[bool]"
    """If true the change will not actually be applied. Dry run may be used to get result
description without actually modifying the code."""
    allowTopFrameEditing: "Optional[bool]"
    """If true, then `scriptSource` is allowed to change the function on top of the stack
as long as the top-most stack frame is the only activation of that function."""


class SetScriptSourceReturns(BaseModel):
    status: "str"
    callFrames: "Optional[List[CallFrame]]" = None
    stackChanged: "Optional[bool]" = None
    asyncStackTrace: "Optional[StackTrace]" = None
    asyncStackTraceId: "Optional[StackTraceId]" = None
    exceptionDetails: "Optional[ExceptionDetails]" = None



class SetSkipAllPausesParameters(TypedDict):
    skip: "bool"
    """New value for skip pauses state."""





class SetVariableValueParameters(TypedDict):
    scopeNumber: "int"
    """0-based number of scope as was listed in scope chain. Only 'local', 'closure' and 'catch'
scope types are allowed. Other scopes could be manipulated manually."""
    variableName: "str"
    """Variable name."""
    newValue: "CallArgument"
    """New variable value."""
    callFrameId: "CallFrameId"
    """Id of callframe that holds variable."""





class StepIntoParameters(TypedDict, total=False):
    breakOnAsyncCall: "bool"
    """Debugger will pause on the execution of the first async task which was scheduled
before next pause."""
    skipList: "List[LocationRange]"
    """The skipList specifies location ranges that should be skipped on step into."""





class StepOverParameters(TypedDict, total=False):
    skipList: "List[LocationRange]"
    """The skipList specifies location ranges that should be skipped on step over."""




# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..runtime.types import CallArgument
        from ..runtime.types import ExceptionDetails
        from ..runtime.types import RemoteObject
        from ..runtime.types import RemoteObjectId
        from ..runtime.types import ScriptId
        from ..runtime.types import StackTrace
        from ..runtime.types import StackTraceId
        from ..runtime.types import TimeDelta
        from ..runtime.types import UniqueDebuggerId
        from .types import BreakLocation
        from .types import BreakpointId
        from .types import CallFrame
        from .types import CallFrameId
        from .types import Location
        from .types import LocationRange
        from .types import ScriptPosition
        from .types import SearchMatch
        from .types import WasmDisassemblyChunk
        # Rebuild models now that imports are available
        EnableReturns.model_rebuild()
        EvaluateOnCallFrameReturns.model_rebuild()
        GetPossibleBreakpointsReturns.model_rebuild()
        GetScriptSourceReturns.model_rebuild()
        DisassembleWasmModuleReturns.model_rebuild()
        NextWasmDisassemblyChunkReturns.model_rebuild()
        GetWasmBytecodeReturns.model_rebuild()
        GetStackTraceReturns.model_rebuild()
        RestartFrameReturns.model_rebuild()
        SearchInContentReturns.model_rebuild()
        SetBreakpointReturns.model_rebuild()
        SetInstrumentationBreakpointReturns.model_rebuild()
        SetBreakpointByUrlReturns.model_rebuild()
        SetBreakpointOnFunctionCallReturns.model_rebuild()
        SetScriptSourceReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
