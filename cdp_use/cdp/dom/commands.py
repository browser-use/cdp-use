# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP DOM Domain Commands"""

from pydantic import BaseModel
from typing import List, Optional
from typing_extensions import TypedDict

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..dom.types import BackendNodeId
    from ..page.types import FrameId
    from ..runtime.types import ExecutionContextId
    from ..runtime.types import RemoteObject
    from ..runtime.types import RemoteObjectId
    from ..runtime.types import StackTrace
    from .types import BackendNodeId
    from .types import BoxModel
    from .types import CSSComputedStyleProperty
    from .types import DetachedElementInfo
    from .types import LogicalAxes
    from .types import Node
    from .types import NodeId
    from .types import PhysicalAxes
    from .types import Quad
    from .types import Rect

class CollectClassNamesFromSubtreeParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to collect class names."""


class CollectClassNamesFromSubtreeReturns(BaseModel):
    classNames: "List[str]"



class CopyToParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to copy."""
    targetNodeId: "NodeId"
    """Id of the element to drop the copy into."""
    insertBeforeNodeId: "Optional[NodeId]"
    """Drop the copy before this node (if absent, the copy becomes the last child of
`targetNodeId`)."""


class CopyToReturns(BaseModel):
    nodeId: "NodeId"



class DescribeNodeParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""
    depth: "int"
    """The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
entire subtree or provide an integer larger than 0."""
    pierce: "bool"
    """Whether or not iframes and shadow roots should be traversed when returning the subtree
(default is false)."""


class DescribeNodeReturns(BaseModel):
    node: "Node"



class ScrollIntoViewIfNeededParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""
    rect: "Rect"
    """The rect to be scrolled into view, relative to the node's border box, in CSS pixels.
When omitted, center of the node will be used, similar to Element.scrollIntoView."""





class DiscardSearchResultsParameters(TypedDict):
    searchId: "str"
    """Unique search session identifier."""





class EnableParameters(TypedDict, total=False):
    includeWhitespace: "str"
    """Whether to include whitespaces in the children array of returned Nodes."""





class FocusParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""





class GetAttributesParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to retrieve attributes for."""


class GetAttributesReturns(BaseModel):
    attributes: "List[str]"



class GetBoxModelParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""


class GetBoxModelReturns(BaseModel):
    model: "BoxModel"



class GetContentQuadsParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""


class GetContentQuadsReturns(BaseModel):
    quads: "List[Quad]"



class GetDocumentParameters(TypedDict, total=False):
    depth: "int"
    """The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
entire subtree or provide an integer larger than 0."""
    pierce: "bool"
    """Whether or not iframes and shadow roots should be traversed when returning the subtree
(default is false)."""


class GetDocumentReturns(BaseModel):
    root: "Node"



class GetFlattenedDocumentParameters(TypedDict, total=False):
    depth: "int"
    """The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
entire subtree or provide an integer larger than 0."""
    pierce: "bool"
    """Whether or not iframes and shadow roots should be traversed when returning the subtree
(default is false)."""


class GetFlattenedDocumentReturns(BaseModel):
    nodes: "List[Node]"



class GetNodesForSubtreeByStyleParameters(TypedDict):
    nodeId: "NodeId"
    """Node ID pointing to the root of a subtree."""
    computedStyles: "List[CSSComputedStyleProperty]"
    """The style to filter nodes by (includes nodes if any of properties matches)."""
    pierce: "Optional[bool]"
    """Whether or not iframes and shadow roots in the same target should be traversed when returning the
results (default is false)."""


class GetNodesForSubtreeByStyleReturns(BaseModel):
    nodeIds: "List[NodeId]"



class GetNodeForLocationParameters(TypedDict):
    x: "int"
    """X coordinate."""
    y: "int"
    """Y coordinate."""
    includeUserAgentShadowDOM: "Optional[bool]"
    """False to skip to the nearest non-UA shadow root ancestor (default: false)."""
    ignorePointerEventsNone: "Optional[bool]"
    """Whether to ignore pointer-events: none on elements and hit test them."""


class GetNodeForLocationReturns(BaseModel):
    backendNodeId: "BackendNodeId"
    frameId: "FrameId"
    nodeId: "Optional[NodeId]" = None



class GetOuterHTMLParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Identifier of the node."""
    backendNodeId: "BackendNodeId"
    """Identifier of the backend node."""
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""
    includeShadowDOM: "bool"
    """Include all shadow roots. Equals to false if not specified."""


class GetOuterHTMLReturns(BaseModel):
    outerHTML: "str"



class GetRelayoutBoundaryParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node."""


class GetRelayoutBoundaryReturns(BaseModel):
    nodeId: "NodeId"



class GetSearchResultsParameters(TypedDict):
    searchId: "str"
    """Unique search session identifier."""
    fromIndex: "int"
    """Start index of the search result to be returned."""
    toIndex: "int"
    """End index of the search result to be returned."""


class GetSearchResultsReturns(BaseModel):
    nodeIds: "List[NodeId]"



class MoveToParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to move."""
    targetNodeId: "NodeId"
    """Id of the element to drop the moved node into."""
    insertBeforeNodeId: "Optional[NodeId]"
    """Drop node before this one (if absent, the moved node becomes the last child of
`targetNodeId`)."""


class MoveToReturns(BaseModel):
    nodeId: "NodeId"



class PerformSearchParameters(TypedDict):
    query: "str"
    """Plain text or query selector or XPath search query."""
    includeUserAgentShadowDOM: "Optional[bool]"
    """True to search in user agent shadow DOM."""


class PerformSearchReturns(BaseModel):
    searchId: "str"
    resultCount: "int"



class PushNodeByPathToFrontendParameters(TypedDict):
    path: "str"
    """Path to node in the proprietary format."""


class PushNodeByPathToFrontendReturns(BaseModel):
    nodeId: "NodeId"



class PushNodesByBackendIdsToFrontendParameters(TypedDict):
    backendNodeIds: "List[BackendNodeId]"
    """The array of backend node ids."""


class PushNodesByBackendIdsToFrontendReturns(BaseModel):
    nodeIds: "List[NodeId]"



class QuerySelectorParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to query upon."""
    selector: "str"
    """Selector string."""


class QuerySelectorReturns(BaseModel):
    nodeId: "NodeId"



class QuerySelectorAllParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to query upon."""
    selector: "str"
    """Selector string."""


class QuerySelectorAllReturns(BaseModel):
    nodeIds: "List[NodeId]"



class GetTopLayerElementsReturns(BaseModel):
    nodeIds: "List[NodeId]"



class GetElementByRelationParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node from which to query the relation."""
    relation: "str"
    """Type of relation to get."""


class GetElementByRelationReturns(BaseModel):
    nodeId: "NodeId"



class RemoveAttributeParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the element to remove attribute from."""
    name: "str"
    """Name of the attribute to remove."""





class RemoveNodeParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to remove."""





class RequestChildNodesParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to get children for."""
    depth: "Optional[int]"
    """The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the
entire subtree or provide an integer larger than 0."""
    pierce: "Optional[bool]"
    """Whether or not iframes and shadow roots should be traversed when returning the sub-tree
(default is false)."""





class RequestNodeParameters(TypedDict):
    objectId: "RemoteObjectId"
    """JavaScript object id to convert into node."""


class RequestNodeReturns(BaseModel):
    nodeId: "NodeId"



class ResolveNodeParameters(TypedDict, total=False):
    nodeId: "NodeId"
    """Id of the node to resolve."""
    backendNodeId: "BackendNodeId"
    """Backend identifier of the node to resolve."""
    objectGroup: "str"
    """Symbolic group name that can be used to release multiple objects."""
    executionContextId: "ExecutionContextId"
    """Execution context in which to resolve the node."""


class ResolveNodeReturns(BaseModel):
    object: "RemoteObject"



class SetAttributeValueParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the element to set attribute for."""
    name: "str"
    """Attribute name."""
    value: "str"
    """Attribute value."""





class SetAttributesAsTextParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the element to set attributes for."""
    text: "str"
    """Text with a number of attributes. Will parse this text using HTML parser."""
    name: "Optional[str]"
    """Attribute name to replace with new attributes derived from text in case text parsed
successfully."""





class SetFileInputFilesParameters(TypedDict):
    files: "List[str]"
    """Array of file paths to set."""
    nodeId: "Optional[NodeId]"
    """Identifier of the node."""
    backendNodeId: "Optional[BackendNodeId]"
    """Identifier of the backend node."""
    objectId: "Optional[RemoteObjectId]"
    """JavaScript object id of the node wrapper."""





class SetNodeStackTracesEnabledParameters(TypedDict):
    enable: "bool"
    """Enable or disable."""





class GetNodeStackTracesParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to get stack traces for."""


class GetNodeStackTracesReturns(BaseModel):
    creation: "Optional[StackTrace]" = None



class GetFileInfoParameters(TypedDict):
    objectId: "RemoteObjectId"
    """JavaScript object id of the node wrapper."""


class GetFileInfoReturns(BaseModel):
    path: "str"



class GetDetachedDomNodesReturns(BaseModel):
    detachedNodes: "List[DetachedElementInfo]"



class SetInspectedNodeParameters(TypedDict):
    nodeId: "NodeId"
    """DOM node id to be accessible by means of $x command line API."""





class SetNodeNameParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to set name for."""
    name: "str"
    """New node's name."""


class SetNodeNameReturns(BaseModel):
    nodeId: "NodeId"



class SetNodeValueParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to set value for."""
    value: "str"
    """New node's value."""





class SetOuterHTMLParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the node to set markup for."""
    outerHTML: "str"
    """Outer HTML markup to set."""





class GetFrameOwnerParameters(TypedDict):
    frameId: "FrameId"


class GetFrameOwnerReturns(BaseModel):
    backendNodeId: "BackendNodeId"
    nodeId: "Optional[NodeId]" = None



class GetContainerForNodeParameters(TypedDict):
    nodeId: "NodeId"
    containerName: "Optional[str]"
    physicalAxes: "Optional[PhysicalAxes]"
    logicalAxes: "Optional[LogicalAxes]"
    queriesScrollState: "Optional[bool]"


class GetContainerForNodeReturns(BaseModel):
    nodeId: "Optional[NodeId]" = None



class GetQueryingDescendantsForContainerParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the container node to find querying descendants from."""


class GetQueryingDescendantsForContainerReturns(BaseModel):
    nodeIds: "List[NodeId]"



class GetAnchorElementParameters(TypedDict):
    nodeId: "NodeId"
    """Id of the positioned element from which to find the anchor."""
    anchorSpecifier: "Optional[str]"
    """An optional anchor specifier, as defined in
https://www.w3.org/TR/css-anchor-position-1/#anchor-specifier.
If not provided, it will return the implicit anchor element for
the given positioned element."""


class GetAnchorElementReturns(BaseModel):
    nodeId: "NodeId"


# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..dom.types import BackendNodeId
        from ..page.types import FrameId
        from ..runtime.types import ExecutionContextId
        from ..runtime.types import RemoteObject
        from ..runtime.types import RemoteObjectId
        from ..runtime.types import StackTrace
        from .types import BackendNodeId
        from .types import BoxModel
        from .types import CSSComputedStyleProperty
        from .types import DetachedElementInfo
        from .types import LogicalAxes
        from .types import Node
        from .types import NodeId
        from .types import PhysicalAxes
        from .types import Quad
        from .types import Rect
        # Rebuild models now that imports are available
        CollectClassNamesFromSubtreeReturns.model_rebuild()
        CopyToReturns.model_rebuild()
        DescribeNodeReturns.model_rebuild()
        GetAttributesReturns.model_rebuild()
        GetBoxModelReturns.model_rebuild()
        GetContentQuadsReturns.model_rebuild()
        GetDocumentReturns.model_rebuild()
        GetFlattenedDocumentReturns.model_rebuild()
        GetNodesForSubtreeByStyleReturns.model_rebuild()
        GetNodeForLocationReturns.model_rebuild()
        GetOuterHTMLReturns.model_rebuild()
        GetRelayoutBoundaryReturns.model_rebuild()
        GetSearchResultsReturns.model_rebuild()
        MoveToReturns.model_rebuild()
        PerformSearchReturns.model_rebuild()
        PushNodeByPathToFrontendReturns.model_rebuild()
        PushNodesByBackendIdsToFrontendReturns.model_rebuild()
        QuerySelectorReturns.model_rebuild()
        QuerySelectorAllReturns.model_rebuild()
        GetTopLayerElementsReturns.model_rebuild()
        GetElementByRelationReturns.model_rebuild()
        RequestNodeReturns.model_rebuild()
        ResolveNodeReturns.model_rebuild()
        GetNodeStackTracesReturns.model_rebuild()
        GetFileInfoReturns.model_rebuild()
        GetDetachedDomNodesReturns.model_rebuild()
        SetNodeNameReturns.model_rebuild()
        GetFrameOwnerReturns.model_rebuild()
        GetContainerForNodeReturns.model_rebuild()
        GetQueryingDescendantsForContainerReturns.model_rebuild()
        GetAnchorElementReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
