# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Storage Domain Types"""

from enum import Enum
from pydantic import BaseModel
from typing import List, Optional, Union

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..network.types import TimeSinceEpoch
    from ..target.types import TargetID

SerializedStorageKey = str



class StorageType(Enum):
    """Enum of possible storage types."""
    COOKIES = "cookies"
    FILE_SYSTEMS = "file_systems"
    INDEXEDDB = "indexeddb"
    LOCAL_STORAGE = "local_storage"
    SHADER_CACHE = "shader_cache"
    WEBSQL = "websql"
    SERVICE_WORKERS = "service_workers"
    CACHE_STORAGE = "cache_storage"
    INTEREST_GROUPS = "interest_groups"
    SHARED_STORAGE = "shared_storage"
    STORAGE_BUCKETS = "storage_buckets"
    ALL = "all"
    OTHER = "other"



class UsageForType(BaseModel):
    """Usage for a storage type."""
    storageType: "Union[StorageType, str]"
    usage: "float"



class TrustTokens(BaseModel):
    """Pair of issuer origin and number of available (signed, but not used) Trust
Tokens from that issuer."""
    issuerOrigin: "str"
    count: "float"



"""Protected audience interest group auction identifier."""
InterestGroupAuctionId = str



class InterestGroupAccessType(Enum):
    """Enum of interest group access types."""
    JOIN = "join"
    LEAVE = "leave"
    UPDATE = "update"
    LOADED = "loaded"
    BID = "bid"
    WIN = "win"
    ADDITIONALBID = "additionalBid"
    ADDITIONALBIDWIN = "additionalBidWin"
    TOPLEVELBID = "topLevelBid"
    TOPLEVELADDITIONALBID = "topLevelAdditionalBid"
    CLEAR = "clear"



class InterestGroupAuctionEventType(Enum):
    """Enum of auction events."""
    STARTED = "started"
    CONFIGRESOLVED = "configResolved"



class InterestGroupAuctionFetchType(Enum):
    """Enum of network fetches auctions can do."""
    BIDDERJS = "bidderJs"
    BIDDERWASM = "bidderWasm"
    SELLERJS = "sellerJs"
    BIDDERTRUSTEDSIGNALS = "bidderTrustedSignals"
    SELLERTRUSTEDSIGNALS = "sellerTrustedSignals"



class SharedStorageAccessScope(Enum):
    """Enum of shared storage access scopes."""
    WINDOW = "window"
    SHAREDSTORAGEWORKLET = "sharedStorageWorklet"
    PROTECTEDAUDIENCEWORKLET = "protectedAudienceWorklet"
    HEADER = "header"



class SharedStorageAccessMethod(Enum):
    """Enum of shared storage access methods."""
    ADDMODULE = "addModule"
    CREATEWORKLET = "createWorklet"
    SELECTURL = "selectURL"
    RUN = "run"
    BATCHUPDATE = "batchUpdate"
    SET = "set"
    APPEND = "append"
    DELETE = "delete"
    CLEAR = "clear"
    GET = "get"
    KEYS = "keys"
    VALUES = "values"
    ENTRIES = "entries"
    LENGTH = "length"
    REMAININGBUDGET = "remainingBudget"



class SharedStorageEntry(BaseModel):
    """Struct for a single key-value pair in an origin's shared storage."""
    key: "str"
    value: "str"



class SharedStorageMetadata(BaseModel):
    """Details for an origin's shared storage."""
    creationTime: "TimeSinceEpoch"
    length: "int"
    remainingBudget: "float"
    bytesUsed: "int"



class SharedStoragePrivateAggregationConfig(BaseModel):
    """Represents a dictionary object passed in as privateAggregationConfig to
run or selectURL."""
    filteringIdMaxBytes: "int"
    aggregationCoordinatorOrigin: "Optional[str]" = None
    contextId: "Optional[str]" = None
    maxContributions: "Optional[int]" = None



class SharedStorageReportingMetadata(BaseModel):
    """Pair of reporting metadata details for a candidate URL for `selectURL()`."""
    eventType: "str"
    reportingUrl: "str"



class SharedStorageUrlWithMetadata(BaseModel):
    """Bundles a candidate URL with its reporting metadata."""
    url: "str"
    reportingMetadata: "List[SharedStorageReportingMetadata]"



class SharedStorageAccessParams(BaseModel):
    """Bundles the parameters for shared storage access events whose
presence/absence can vary according to SharedStorageAccessType."""
    scriptSourceUrl: "Optional[str]" = None
    dataOrigin: "Optional[str]" = None
    operationName: "Optional[str]" = None
    operationId: "Optional[str]" = None
    keepAlive: "Optional[bool]" = None
    privateAggregationConfig: "Optional[SharedStoragePrivateAggregationConfig]" = None
    serializedData: "Optional[str]" = None
    urlsWithMetadata: "Optional[List[SharedStorageUrlWithMetadata]]" = None
    urnUuid: "Optional[str]" = None
    key: "Optional[str]" = None
    value: "Optional[str]" = None
    ignoreIfPresent: "Optional[bool]" = None
    workletOrdinal: "Optional[int]" = None
    workletTargetId: "Optional[TargetID]" = None
    withLock: "Optional[str]" = None
    batchUpdateId: "Optional[str]" = None
    batchSize: "Optional[int]" = None



class StorageBucketsDurability(Enum):
    RELAXED = "relaxed"
    STRICT = "strict"



class StorageBucket(BaseModel):
    storageKey: "SerializedStorageKey"
    name: "Optional[str]" = None



class StorageBucketInfo(BaseModel):
    bucket: "StorageBucket"
    id: "str"
    expiration: "TimeSinceEpoch"
    quota: "float"
    persistent: "bool"
    durability: "Union[StorageBucketsDurability, str]"



class AttributionReportingSourceType(Enum):
    NAVIGATION = "navigation"
    EVENT = "event"



UnsignedInt64AsBase10 = str



UnsignedInt128AsBase16 = str



SignedInt64AsBase10 = str



class AttributionReportingFilterDataEntry(BaseModel):
    key: "str"
    values: "List[str]"



class AttributionReportingFilterConfig(BaseModel):
    filterValues: "List[AttributionReportingFilterDataEntry]"
    lookbackWindow: "Optional[int]" = None



class AttributionReportingFilterPair(BaseModel):
    filters: "List[AttributionReportingFilterConfig]"
    notFilters: "List[AttributionReportingFilterConfig]"



class AttributionReportingAggregationKeysEntry(BaseModel):
    key: "str"
    value: "UnsignedInt128AsBase16"



class AttributionReportingEventReportWindows(BaseModel):
    start: "int"
    ends: "List[int]"



class AttributionReportingTriggerDataMatching(Enum):
    EXACT = "exact"
    MODULUS = "modulus"



class AttributionReportingAggregatableDebugReportingData(BaseModel):
    keyPiece: "UnsignedInt128AsBase16"
    value: "float"
    types: "List[str]"



class AttributionReportingAggregatableDebugReportingConfig(BaseModel):
    keyPiece: "UnsignedInt128AsBase16"
    debugData: "List[AttributionReportingAggregatableDebugReportingData]"
    budget: "Optional[float]" = None
    aggregationCoordinatorOrigin: "Optional[str]" = None



class AttributionScopesData(BaseModel):
    values: "List[str]"
    limit: "float"
    maxEventStates: "float"



class AttributionReportingNamedBudgetDef(BaseModel):
    name: "str"
    budget: "int"



class AttributionReportingSourceRegistration(BaseModel):
    time: "TimeSinceEpoch"
    expiry: "int"
    triggerData: "List[float]"
    eventReportWindows: "AttributionReportingEventReportWindows"
    aggregatableReportWindow: "int"
    type: "Union[AttributionReportingSourceType, str]"
    sourceOrigin: "str"
    reportingOrigin: "str"
    destinationSites: "List[str]"
    eventId: "UnsignedInt64AsBase10"
    priority: "SignedInt64AsBase10"
    filterData: "List[AttributionReportingFilterDataEntry]"
    aggregationKeys: "List[AttributionReportingAggregationKeysEntry]"
    triggerDataMatching: "Union[AttributionReportingTriggerDataMatching, str]"
    destinationLimitPriority: "SignedInt64AsBase10"
    aggregatableDebugReportingConfig: "AttributionReportingAggregatableDebugReportingConfig"
    maxEventLevelReports: "int"
    namedBudgets: "List[AttributionReportingNamedBudgetDef]"
    debugReporting: "bool"
    eventLevelEpsilon: "float"
    debugKey: "Optional[UnsignedInt64AsBase10]" = None
    scopesData: "Optional[AttributionScopesData]" = None



class AttributionReportingSourceRegistrationResult(Enum):
    SUCCESS = "success"
    INTERNALERROR = "internalError"
    INSUFFICIENTSOURCECAPACITY = "insufficientSourceCapacity"
    INSUFFICIENTUNIQUEDESTINATIONCAPACITY = "insufficientUniqueDestinationCapacity"
    EXCESSIVEREPORTINGORIGINS = "excessiveReportingOrigins"
    PROHIBITEDBYBROWSERPOLICY = "prohibitedByBrowserPolicy"
    SUCCESSNOISED = "successNoised"
    DESTINATIONREPORTINGLIMITREACHED = "destinationReportingLimitReached"
    DESTINATIONGLOBALLIMITREACHED = "destinationGlobalLimitReached"
    DESTINATIONBOTHLIMITSREACHED = "destinationBothLimitsReached"
    REPORTINGORIGINSPERSITELIMITREACHED = "reportingOriginsPerSiteLimitReached"
    EXCEEDSMAXCHANNELCAPACITY = "exceedsMaxChannelCapacity"
    EXCEEDSMAXSCOPESCHANNELCAPACITY = "exceedsMaxScopesChannelCapacity"
    EXCEEDSMAXTRIGGERSTATECARDINALITY = "exceedsMaxTriggerStateCardinality"
    EXCEEDSMAXEVENTSTATESLIMIT = "exceedsMaxEventStatesLimit"
    DESTINATIONPERDAYREPORTINGLIMITREACHED = "destinationPerDayReportingLimitReached"



class AttributionReportingSourceRegistrationTimeConfig(Enum):
    INCLUDE = "include"
    EXCLUDE = "exclude"



class AttributionReportingAggregatableValueDictEntry(BaseModel):
    key: "str"
    value: "float"
    filteringId: "UnsignedInt64AsBase10"



class AttributionReportingAggregatableValueEntry(BaseModel):
    values: "List[AttributionReportingAggregatableValueDictEntry]"
    filters: "AttributionReportingFilterPair"



class AttributionReportingEventTriggerData(BaseModel):
    data: "UnsignedInt64AsBase10"
    priority: "SignedInt64AsBase10"
    filters: "AttributionReportingFilterPair"
    dedupKey: "Optional[UnsignedInt64AsBase10]" = None



class AttributionReportingAggregatableTriggerData(BaseModel):
    keyPiece: "UnsignedInt128AsBase16"
    sourceKeys: "List[str]"
    filters: "AttributionReportingFilterPair"



class AttributionReportingAggregatableDedupKey(BaseModel):
    filters: "AttributionReportingFilterPair"
    dedupKey: "Optional[UnsignedInt64AsBase10]" = None



class AttributionReportingNamedBudgetCandidate(BaseModel):
    filters: "AttributionReportingFilterPair"
    name: "Optional[str]" = None



class AttributionReportingTriggerRegistration(BaseModel):
    filters: "AttributionReportingFilterPair"
    aggregatableDedupKeys: "List[AttributionReportingAggregatableDedupKey]"
    eventTriggerData: "List[AttributionReportingEventTriggerData]"
    aggregatableTriggerData: "List[AttributionReportingAggregatableTriggerData]"
    aggregatableValues: "List[AttributionReportingAggregatableValueEntry]"
    aggregatableFilteringIdMaxBytes: "int"
    debugReporting: "bool"
    sourceRegistrationTimeConfig: "Union[AttributionReportingSourceRegistrationTimeConfig, str]"
    aggregatableDebugReportingConfig: "AttributionReportingAggregatableDebugReportingConfig"
    scopes: "List[str]"
    namedBudgets: "List[AttributionReportingNamedBudgetCandidate]"
    debugKey: "Optional[UnsignedInt64AsBase10]" = None
    aggregationCoordinatorOrigin: "Optional[str]" = None
    triggerContextId: "Optional[str]" = None



class AttributionReportingEventLevelResult(Enum):
    SUCCESS = "success"
    SUCCESSDROPPEDLOWERPRIORITY = "successDroppedLowerPriority"
    INTERNALERROR = "internalError"
    NOCAPACITYFORATTRIBUTIONDESTINATION = "noCapacityForAttributionDestination"
    NOMATCHINGSOURCES = "noMatchingSources"
    DEDUPLICATED = "deduplicated"
    EXCESSIVEATTRIBUTIONS = "excessiveAttributions"
    PRIORITYTOOLOW = "priorityTooLow"
    NEVERATTRIBUTEDSOURCE = "neverAttributedSource"
    EXCESSIVEREPORTINGORIGINS = "excessiveReportingOrigins"
    NOMATCHINGSOURCEFILTERDATA = "noMatchingSourceFilterData"
    PROHIBITEDBYBROWSERPOLICY = "prohibitedByBrowserPolicy"
    NOMATCHINGCONFIGURATIONS = "noMatchingConfigurations"
    EXCESSIVEREPORTS = "excessiveReports"
    FALSELYATTRIBUTEDSOURCE = "falselyAttributedSource"
    REPORTWINDOWPASSED = "reportWindowPassed"
    NOTREGISTERED = "notRegistered"
    REPORTWINDOWNOTSTARTED = "reportWindowNotStarted"
    NOMATCHINGTRIGGERDATA = "noMatchingTriggerData"



class AttributionReportingAggregatableResult(Enum):
    SUCCESS = "success"
    INTERNALERROR = "internalError"
    NOCAPACITYFORATTRIBUTIONDESTINATION = "noCapacityForAttributionDestination"
    NOMATCHINGSOURCES = "noMatchingSources"
    EXCESSIVEATTRIBUTIONS = "excessiveAttributions"
    EXCESSIVEREPORTINGORIGINS = "excessiveReportingOrigins"
    NOHISTOGRAMS = "noHistograms"
    INSUFFICIENTBUDGET = "insufficientBudget"
    INSUFFICIENTNAMEDBUDGET = "insufficientNamedBudget"
    NOMATCHINGSOURCEFILTERDATA = "noMatchingSourceFilterData"
    NOTREGISTERED = "notRegistered"
    PROHIBITEDBYBROWSERPOLICY = "prohibitedByBrowserPolicy"
    DEDUPLICATED = "deduplicated"
    REPORTWINDOWPASSED = "reportWindowPassed"
    EXCESSIVEREPORTS = "excessiveReports"



class AttributionReportingReportResult(Enum):
    SENT = "sent"
    PROHIBITED = "prohibited"
    FAILEDTOASSEMBLE = "failedToAssemble"
    EXPIRED = "expired"



class RelatedWebsiteSet(BaseModel):
    """A single Related Website Set object."""
    primarySites: "List[str]"
    associatedSites: "List[str]"
    serviceSites: "List[str]"


# Rebuild Pydantic models to resolve forward references
# Import dependencies for model rebuilding
def _rebuild_models_when_ready():
    try:
        from ..network.types import TimeSinceEpoch
        from ..target.types import TargetID
        # Rebuild models now that imports are available
        UsageForType.model_rebuild()
        TrustTokens.model_rebuild()
        SharedStorageEntry.model_rebuild()
        SharedStorageMetadata.model_rebuild()
        SharedStoragePrivateAggregationConfig.model_rebuild()
        SharedStorageReportingMetadata.model_rebuild()
        SharedStorageUrlWithMetadata.model_rebuild()
        SharedStorageAccessParams.model_rebuild()
        StorageBucket.model_rebuild()
        StorageBucketInfo.model_rebuild()
        AttributionReportingFilterDataEntry.model_rebuild()
        AttributionReportingFilterConfig.model_rebuild()
        AttributionReportingFilterPair.model_rebuild()
        AttributionReportingAggregationKeysEntry.model_rebuild()
        AttributionReportingEventReportWindows.model_rebuild()
        AttributionReportingAggregatableDebugReportingData.model_rebuild()
        AttributionReportingAggregatableDebugReportingConfig.model_rebuild()
        AttributionScopesData.model_rebuild()
        AttributionReportingNamedBudgetDef.model_rebuild()
        AttributionReportingSourceRegistration.model_rebuild()
        AttributionReportingAggregatableValueDictEntry.model_rebuild()
        AttributionReportingAggregatableValueEntry.model_rebuild()
        AttributionReportingEventTriggerData.model_rebuild()
        AttributionReportingAggregatableTriggerData.model_rebuild()
        AttributionReportingAggregatableDedupKey.model_rebuild()
        AttributionReportingNamedBudgetCandidate.model_rebuild()
        AttributionReportingTriggerRegistration.model_rebuild()
        RelatedWebsiteSet.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
