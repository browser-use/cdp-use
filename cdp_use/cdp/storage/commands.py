# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Storage Domain Commands"""

from pydantic import BaseModel
from typing import Any, Dict, List, Optional
from typing_extensions import TypedDict

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..browser.types import BrowserContextID
    from ..network.types import Cookie
    from ..network.types import CookieParam
    from ..page.types import FrameId
    from .types import RelatedWebsiteSet
    from .types import SerializedStorageKey
    from .types import SharedStorageEntry
    from .types import SharedStorageMetadata
    from .types import StorageBucket
    from .types import TrustTokens
    from .types import UsageForType

class GetStorageKeyForFrameParameters(TypedDict):
    frameId: "FrameId"


class GetStorageKeyForFrameReturns(BaseModel):
    storageKey: "SerializedStorageKey"



class ClearDataForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""
    storageTypes: "str"
    """Comma separated list of StorageType to clear."""





class ClearDataForStorageKeyParameters(TypedDict):
    storageKey: "str"
    """Storage key."""
    storageTypes: "str"
    """Comma separated list of StorageType to clear."""





class GetCookiesParameters(TypedDict, total=False):
    browserContextId: "BrowserContextID"
    """Browser context to use when called on the browser endpoint."""


class GetCookiesReturns(BaseModel):
    cookies: "List[Cookie]"



class SetCookiesParameters(TypedDict):
    cookies: "List[CookieParam]"
    """Cookies to be set."""
    browserContextId: "Optional[BrowserContextID]"
    """Browser context to use when called on the browser endpoint."""





class ClearCookiesParameters(TypedDict, total=False):
    browserContextId: "BrowserContextID"
    """Browser context to use when called on the browser endpoint."""





class GetUsageAndQuotaParameters(TypedDict):
    origin: "str"
    """Security origin."""


class GetUsageAndQuotaReturns(BaseModel):
    usage: "float"
    quota: "float"
    overrideActive: "bool"
    usageBreakdown: "List[UsageForType]"



class OverrideQuotaForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""
    quotaSize: "Optional[float]"
    """The quota size (in bytes) to override the original quota with.
If this is called multiple times, the overridden quota will be equal to
the quotaSize provided in the final call. If this is called without
specifying a quotaSize, the quota will be reset to the default value for
the specified origin. If this is called multiple times with different
origins, the override will be maintained for each origin until it is
disabled (called without a quotaSize)."""





class TrackCacheStorageForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""





class TrackCacheStorageForStorageKeyParameters(TypedDict):
    storageKey: "str"
    """Storage key."""





class TrackIndexedDBForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""





class TrackIndexedDBForStorageKeyParameters(TypedDict):
    storageKey: "str"
    """Storage key."""





class UntrackCacheStorageForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""





class UntrackCacheStorageForStorageKeyParameters(TypedDict):
    storageKey: "str"
    """Storage key."""





class UntrackIndexedDBForOriginParameters(TypedDict):
    origin: "str"
    """Security origin."""





class UntrackIndexedDBForStorageKeyParameters(TypedDict):
    storageKey: "str"
    """Storage key."""





class GetTrustTokensReturns(BaseModel):
    tokens: "List[TrustTokens]"



class ClearTrustTokensParameters(TypedDict):
    issuerOrigin: "str"


class ClearTrustTokensReturns(BaseModel):
    didDeleteTokens: "bool"



class GetInterestGroupDetailsParameters(TypedDict):
    ownerOrigin: "str"
    name: "str"


class GetInterestGroupDetailsReturns(BaseModel):
    details: "Dict[str, Any]"



class SetInterestGroupTrackingParameters(TypedDict):
    enable: "bool"





class SetInterestGroupAuctionTrackingParameters(TypedDict):
    enable: "bool"





class GetSharedStorageMetadataParameters(TypedDict):
    ownerOrigin: "str"


class GetSharedStorageMetadataReturns(BaseModel):
    metadata: "SharedStorageMetadata"



class GetSharedStorageEntriesParameters(TypedDict):
    ownerOrigin: "str"


class GetSharedStorageEntriesReturns(BaseModel):
    entries: "List[SharedStorageEntry]"



class SetSharedStorageEntryParameters(TypedDict):
    ownerOrigin: "str"
    key: "str"
    value: "str"
    ignoreIfPresent: "Optional[bool]"
    """If `ignoreIfPresent` is included and true, then only sets the entry if
`key` doesn't already exist."""





class DeleteSharedStorageEntryParameters(TypedDict):
    ownerOrigin: "str"
    key: "str"





class ClearSharedStorageEntriesParameters(TypedDict):
    ownerOrigin: "str"





class ResetSharedStorageBudgetParameters(TypedDict):
    ownerOrigin: "str"





class SetSharedStorageTrackingParameters(TypedDict):
    enable: "bool"





class SetStorageBucketTrackingParameters(TypedDict):
    storageKey: "str"
    enable: "bool"





class DeleteStorageBucketParameters(TypedDict):
    bucket: "StorageBucket"





class RunBounceTrackingMitigationsReturns(BaseModel):
    deletedSites: "List[str]"



class SetAttributionReportingLocalTestingModeParameters(TypedDict):
    enabled: "bool"
    """If enabled, noise is suppressed and reports are sent immediately."""





class SetAttributionReportingTrackingParameters(TypedDict):
    enable: "bool"





class SendPendingAttributionReportsReturns(BaseModel):
    numSent: "int"



class GetRelatedWebsiteSetsReturns(BaseModel):
    sets: "List[RelatedWebsiteSet]"



class GetAffectedUrlsForThirdPartyCookieMetadataParameters(TypedDict):
    firstPartyUrl: "str"
    """The URL of the page currently being visited."""
    thirdPartyUrls: "List[str]"
    """The list of embedded resource URLs from the page."""


class GetAffectedUrlsForThirdPartyCookieMetadataReturns(BaseModel):
    matchedUrls: "List[str]"



class SetProtectedAudienceKAnonymityParameters(TypedDict):
    owner: "str"
    name: "str"
    hashes: "List[str]"




# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..browser.types import BrowserContextID
        from ..network.types import Cookie
        from ..network.types import CookieParam
        from ..page.types import FrameId
        from .types import RelatedWebsiteSet
        from .types import SerializedStorageKey
        from .types import SharedStorageEntry
        from .types import SharedStorageMetadata
        from .types import StorageBucket
        from .types import TrustTokens
        from .types import UsageForType
        # Rebuild models now that imports are available
        GetStorageKeyForFrameReturns.model_rebuild()
        GetCookiesReturns.model_rebuild()
        GetUsageAndQuotaReturns.model_rebuild()
        GetTrustTokensReturns.model_rebuild()
        ClearTrustTokensReturns.model_rebuild()
        GetInterestGroupDetailsReturns.model_rebuild()
        GetSharedStorageMetadataReturns.model_rebuild()
        GetSharedStorageEntriesReturns.model_rebuild()
        RunBounceTrackingMitigationsReturns.model_rebuild()
        SendPendingAttributionReportsReturns.model_rebuild()
        GetRelatedWebsiteSetsReturns.model_rebuild()
        GetAffectedUrlsForThirdPartyCookieMetadataReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
