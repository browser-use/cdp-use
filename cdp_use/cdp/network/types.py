# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Network Domain Types"""

from enum import Enum
from pydantic import BaseModel
from typing import Any, Dict, List, Optional, Union

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..io.types import StreamHandle
    from ..runtime.types import StackTrace
    from ..security.types import CertificateId
    from ..security.types import MixedContentType
    from ..security.types import SecurityState

class ResourceType(Enum):
    """Resource type as it was perceived by the rendering engine."""
    DOCUMENT = "Document"
    STYLESHEET = "Stylesheet"
    IMAGE = "Image"
    MEDIA = "Media"
    FONT = "Font"
    SCRIPT = "Script"
    TEXTTRACK = "TextTrack"
    XHR = "XHR"
    FETCH = "Fetch"
    PREFETCH = "Prefetch"
    EVENTSOURCE = "EventSource"
    WEBSOCKET = "WebSocket"
    MANIFEST = "Manifest"
    SIGNEDEXCHANGE = "SignedExchange"
    PING = "Ping"
    CSPVIOLATIONREPORT = "CSPViolationReport"
    PREFLIGHT = "Preflight"
    FEDCM = "FedCM"
    OTHER = "Other"



"""Unique loader identifier."""
LoaderId = str



"""Unique network request identifier.
Note that this does not identify individual HTTP requests that are part of
a network request."""
RequestId = str



"""Unique intercepted request identifier."""
InterceptionId = str



class ErrorReason(Enum):
    """Network level fetch failure reason."""
    FAILED = "Failed"
    ABORTED = "Aborted"
    TIMEDOUT = "TimedOut"
    ACCESSDENIED = "AccessDenied"
    CONNECTIONCLOSED = "ConnectionClosed"
    CONNECTIONRESET = "ConnectionReset"
    CONNECTIONREFUSED = "ConnectionRefused"
    CONNECTIONABORTED = "ConnectionAborted"
    CONNECTIONFAILED = "ConnectionFailed"
    NAMENOTRESOLVED = "NameNotResolved"
    INTERNETDISCONNECTED = "InternetDisconnected"
    ADDRESSUNREACHABLE = "AddressUnreachable"
    BLOCKEDBYCLIENT = "BlockedByClient"
    BLOCKEDBYRESPONSE = "BlockedByResponse"



"""UTC time in seconds, counted from January 1, 1970."""
TimeSinceEpoch = float



"""Monotonically increasing time in seconds since an arbitrary point in the past."""
MonotonicTime = float



class Headers(BaseModel):
    """Request / response headers as keys / values of JSON object."""
    pass



class ConnectionType(Enum):
    """The underlying connection technology that the browser is supposedly using."""
    NONE = "none"
    CELLULAR2G = "cellular2g"
    CELLULAR3G = "cellular3g"
    CELLULAR4G = "cellular4g"
    BLUETOOTH = "bluetooth"
    ETHERNET = "ethernet"
    WIFI = "wifi"
    WIMAX = "wimax"
    OTHER = "other"



class CookieSameSite(Enum):
    """Represents the cookie's 'SameSite' status:
https://tools.ietf.org/html/draft-west-first-party-cookies"""
    STRICT = "Strict"
    LAX = "Lax"
    NONE = "None"



class CookiePriority(Enum):
    """Represents the cookie's 'Priority' status:
https://tools.ietf.org/html/draft-west-cookie-priority-00"""
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"



class CookieSourceScheme(Enum):
    """Represents the source scheme of the origin that originally set the cookie.
A value of \"Unset\" allows protocol clients to emulate legacy cookie scope for the scheme.
This is a temporary ability and it will be removed in the future."""
    UNSET = "Unset"
    NONSECURE = "NonSecure"
    SECURE = "Secure"



class ResourceTiming(BaseModel):
    """Timing information for the request."""
    requestTime: "float"
    proxyStart: "float"
    proxyEnd: "float"
    dnsStart: "float"
    dnsEnd: "float"
    connectStart: "float"
    connectEnd: "float"
    sslStart: "float"
    sslEnd: "float"
    workerStart: "float"
    workerReady: "float"
    workerFetchStart: "float"
    workerRespondWithSettled: "float"
    sendStart: "float"
    sendEnd: "float"
    pushStart: "float"
    pushEnd: "float"
    receiveHeadersStart: "float"
    receiveHeadersEnd: "float"
    workerRouterEvaluationStart: "Optional[float]" = None
    workerCacheLookupStart: "Optional[float]" = None



class ResourcePriority(Enum):
    """Loading priority of a resource request."""
    VERYLOW = "VeryLow"
    LOW = "Low"
    MEDIUM = "Medium"
    HIGH = "High"
    VERYHIGH = "VeryHigh"



class PostDataEntry(BaseModel):
    """Post data entry for HTTP request"""
    bytes: "Optional[str]" = None



class Request(BaseModel):
    """HTTP request data."""
    url: "str"
    method: "str"
    headers: "Headers"
    initialPriority: "Union[ResourcePriority, str]"
    referrerPolicy: "str"
    urlFragment: "Optional[str]" = None
    postData: "Optional[str]" = None
    hasPostData: "Optional[bool]" = None
    postDataEntries: "Optional[List[PostDataEntry]]" = None
    mixedContentType: "Optional[Union[MixedContentType, str]]" = None
    isLinkPreload: "Optional[bool]" = None
    trustTokenParams: "Optional[TrustTokenParams]" = None
    isSameSite: "Optional[bool]" = None



class SignedCertificateTimestamp(BaseModel):
    """Details of a signed certificate timestamp (SCT)."""
    status: "str"
    origin: "str"
    logDescription: "str"
    logId: "str"
    timestamp: "float"
    hashAlgorithm: "str"
    signatureAlgorithm: "str"
    signatureData: "str"



class SecurityDetails(BaseModel):
    """Security details about a request."""
    protocol: "str"
    keyExchange: "str"
    cipher: "str"
    certificateId: "CertificateId"
    subjectName: "str"
    sanList: "List[str]"
    issuer: "str"
    validFrom: "TimeSinceEpoch"
    validTo: "TimeSinceEpoch"
    signedCertificateTimestampList: "List[SignedCertificateTimestamp]"
    certificateTransparencyCompliance: "Union[CertificateTransparencyCompliance, str]"
    encryptedClientHello: "bool"
    keyExchangeGroup: "Optional[str]" = None
    mac: "Optional[str]" = None
    serverSignatureAlgorithm: "Optional[int]" = None



class CertificateTransparencyCompliance(Enum):
    """Whether the request complied with Certificate Transparency policy."""
    UNKNOWN = "unknown"
    NOT_COMPLIANT = "not-compliant"
    COMPLIANT = "compliant"



class BlockedReason(Enum):
    """The reason why request was blocked."""
    OTHER = "other"
    CSP = "csp"
    MIXED_CONTENT = "mixed-content"
    ORIGIN = "origin"
    INSPECTOR = "inspector"
    INTEGRITY = "integrity"
    SUBRESOURCE_FILTER = "subresource-filter"
    CONTENT_TYPE = "content-type"
    COEP_FRAME_RESOURCE_NEEDS_COEP_HEADER = "coep-frame-resource-needs-coep-header"
    COOP_SANDBOXED_IFRAME_CANNOT_NAVIGATE_TO_COOP_PAGE = "coop-sandboxed-iframe-cannot-navigate-to-coop-page"
    CORP_NOT_SAME_ORIGIN = "corp-not-same-origin"
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_COEP = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep"
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_DIP = "corp-not-same-origin-after-defaulted-to-same-origin-by-dip"
    CORP_NOT_SAME_ORIGIN_AFTER_DEFAULTED_TO_SAME_ORIGIN_BY_COEP_AND_DIP = "corp-not-same-origin-after-defaulted-to-same-origin-by-coep-and-dip"
    CORP_NOT_SAME_SITE = "corp-not-same-site"
    SRI_MESSAGE_SIGNATURE_MISMATCH = "sri-message-signature-mismatch"



class CorsError(Enum):
    """The reason why request was blocked."""
    DISALLOWEDBYMODE = "DisallowedByMode"
    INVALIDRESPONSE = "InvalidResponse"
    WILDCARDORIGINNOTALLOWED = "WildcardOriginNotAllowed"
    MISSINGALLOWORIGINHEADER = "MissingAllowOriginHeader"
    MULTIPLEALLOWORIGINVALUES = "MultipleAllowOriginValues"
    INVALIDALLOWORIGINVALUE = "InvalidAllowOriginValue"
    ALLOWORIGINMISMATCH = "AllowOriginMismatch"
    INVALIDALLOWCREDENTIALS = "InvalidAllowCredentials"
    CORSDISABLEDSCHEME = "CorsDisabledScheme"
    PREFLIGHTINVALIDSTATUS = "PreflightInvalidStatus"
    PREFLIGHTDISALLOWEDREDIRECT = "PreflightDisallowedRedirect"
    PREFLIGHTWILDCARDORIGINNOTALLOWED = "PreflightWildcardOriginNotAllowed"
    PREFLIGHTMISSINGALLOWORIGINHEADER = "PreflightMissingAllowOriginHeader"
    PREFLIGHTMULTIPLEALLOWORIGINVALUES = "PreflightMultipleAllowOriginValues"
    PREFLIGHTINVALIDALLOWORIGINVALUE = "PreflightInvalidAllowOriginValue"
    PREFLIGHTALLOWORIGINMISMATCH = "PreflightAllowOriginMismatch"
    PREFLIGHTINVALIDALLOWCREDENTIALS = "PreflightInvalidAllowCredentials"
    PREFLIGHTMISSINGALLOWEXTERNAL = "PreflightMissingAllowExternal"
    PREFLIGHTINVALIDALLOWEXTERNAL = "PreflightInvalidAllowExternal"
    PREFLIGHTMISSINGALLOWPRIVATENETWORK = "PreflightMissingAllowPrivateNetwork"
    PREFLIGHTINVALIDALLOWPRIVATENETWORK = "PreflightInvalidAllowPrivateNetwork"
    INVALIDALLOWMETHODSPREFLIGHTRESPONSE = "InvalidAllowMethodsPreflightResponse"
    INVALIDALLOWHEADERSPREFLIGHTRESPONSE = "InvalidAllowHeadersPreflightResponse"
    METHODDISALLOWEDBYPREFLIGHTRESPONSE = "MethodDisallowedByPreflightResponse"
    HEADERDISALLOWEDBYPREFLIGHTRESPONSE = "HeaderDisallowedByPreflightResponse"
    REDIRECTCONTAINSCREDENTIALS = "RedirectContainsCredentials"
    INSECUREPRIVATENETWORK = "InsecurePrivateNetwork"
    INVALIDPRIVATENETWORKACCESS = "InvalidPrivateNetworkAccess"
    UNEXPECTEDPRIVATENETWORKACCESS = "UnexpectedPrivateNetworkAccess"
    NOCORSREDIRECTMODENOTFOLLOW = "NoCorsRedirectModeNotFollow"
    PREFLIGHTMISSINGPRIVATENETWORKACCESSID = "PreflightMissingPrivateNetworkAccessId"
    PREFLIGHTMISSINGPRIVATENETWORKACCESSNAME = "PreflightMissingPrivateNetworkAccessName"
    PRIVATENETWORKACCESSPERMISSIONUNAVAILABLE = "PrivateNetworkAccessPermissionUnavailable"
    PRIVATENETWORKACCESSPERMISSIONDENIED = "PrivateNetworkAccessPermissionDenied"
    LOCALNETWORKACCESSPERMISSIONDENIED = "LocalNetworkAccessPermissionDenied"



class CorsErrorStatus(BaseModel):
    corsError: "Union[CorsError, str]"
    failedParameter: "str"



class ServiceWorkerResponseSource(Enum):
    """Source of serviceworker response."""
    CACHE_STORAGE = "cache-storage"
    HTTP_CACHE = "http-cache"
    FALLBACK_CODE = "fallback-code"
    NETWORK = "network"



class TrustTokenParams(BaseModel):
    """Determines what type of Trust Token operation is executed and
depending on the type, some additional parameters. The values
are specified in third_party/blink/renderer/core/fetch/trust_token.idl."""
    operation: "Union[TrustTokenOperationType, str]"
    refreshPolicy: "str"
    issuers: "Optional[List[str]]" = None



class TrustTokenOperationType(Enum):
    ISSUANCE = "Issuance"
    REDEMPTION = "Redemption"
    SIGNING = "Signing"



class AlternateProtocolUsage(Enum):
    """The reason why Chrome uses a specific transport protocol for HTTP semantics."""
    ALTERNATIVEJOBWONWITHOUTRACE = "alternativeJobWonWithoutRace"
    ALTERNATIVEJOBWONRACE = "alternativeJobWonRace"
    MAINJOBWONRACE = "mainJobWonRace"
    MAPPINGMISSING = "mappingMissing"
    BROKEN = "broken"
    DNSALPNH3JOBWONWITHOUTRACE = "dnsAlpnH3JobWonWithoutRace"
    DNSALPNH3JOBWONRACE = "dnsAlpnH3JobWonRace"
    UNSPECIFIEDREASON = "unspecifiedReason"



class ServiceWorkerRouterSource(Enum):
    """Source of service worker router."""
    NETWORK = "network"
    CACHE = "cache"
    FETCH_EVENT = "fetch-event"
    RACE_NETWORK_AND_FETCH_HANDLER = "race-network-and-fetch-handler"
    RACE_NETWORK_AND_CACHE = "race-network-and-cache"



class ServiceWorkerRouterInfo(BaseModel):
    ruleIdMatched: "Optional[int]" = None
    matchedSourceType: "Optional[Union[ServiceWorkerRouterSource, str]]" = None
    actualSourceType: "Optional[Union[ServiceWorkerRouterSource, str]]" = None



class Response(BaseModel):
    """HTTP response data."""
    url: "str"
    status: "int"
    statusText: "str"
    headers: "Headers"
    mimeType: "str"
    charset: "str"
    connectionReused: "bool"
    connectionId: "float"
    encodedDataLength: "float"
    securityState: "Union[SecurityState, str]"
    headersText: "Optional[str]" = None
    requestHeaders: "Optional[Headers]" = None
    requestHeadersText: "Optional[str]" = None
    remoteIPAddress: "Optional[str]" = None
    remotePort: "Optional[int]" = None
    fromDiskCache: "Optional[bool]" = None
    fromServiceWorker: "Optional[bool]" = None
    fromPrefetchCache: "Optional[bool]" = None
    fromEarlyHints: "Optional[bool]" = None
    serviceWorkerRouterInfo: "Optional[ServiceWorkerRouterInfo]" = None
    timing: "Optional[ResourceTiming]" = None
    serviceWorkerResponseSource: "Optional[Union[ServiceWorkerResponseSource, str]]" = None
    responseTime: "Optional[TimeSinceEpoch]" = None
    cacheStorageCacheName: "Optional[str]" = None
    protocol: "Optional[str]" = None
    alternateProtocolUsage: "Optional[Union[AlternateProtocolUsage, str]]" = None
    securityDetails: "Optional[SecurityDetails]" = None



class WebSocketRequest(BaseModel):
    """WebSocket request data."""
    headers: "Headers"



class WebSocketResponse(BaseModel):
    """WebSocket response data."""
    status: "int"
    statusText: "str"
    headers: "Headers"
    headersText: "Optional[str]" = None
    requestHeaders: "Optional[Headers]" = None
    requestHeadersText: "Optional[str]" = None



class WebSocketFrame(BaseModel):
    """WebSocket message data. This represents an entire WebSocket message, not just a fragmented frame as the name suggests."""
    opcode: "float"
    mask: "bool"
    payloadData: "str"



class CachedResource(BaseModel):
    """Information about the cached resource."""
    url: "str"
    type: "Union[ResourceType, str]"
    bodySize: "float"
    response: "Optional[Response]" = None



class Initiator(BaseModel):
    """Information about the request initiator."""
    type: "str"
    stack: "Optional[StackTrace]" = None
    url: "Optional[str]" = None
    lineNumber: "Optional[float]" = None
    columnNumber: "Optional[float]" = None
    requestId: "Optional[RequestId]" = None



class CookiePartitionKey(BaseModel):
    """cookiePartitionKey object
The representation of the components of the key that are created by the cookiePartitionKey class contained in net/cookies/cookie_partition_key.h."""
    topLevelSite: "str"
    hasCrossSiteAncestor: "bool"



class Cookie(BaseModel):
    """Cookie object"""
    name: "str"
    value: "str"
    domain: "str"
    path: "str"
    expires: "float"
    size: "int"
    httpOnly: "bool"
    secure: "bool"
    session: "bool"
    priority: "Union[CookiePriority, str]"
    sameParty: "bool"
    sourceScheme: "Union[CookieSourceScheme, str]"
    sourcePort: "int"
    sameSite: "Optional[Union[CookieSameSite, str]]" = None
    partitionKey: "Optional[CookiePartitionKey]" = None
    partitionKeyOpaque: "Optional[bool]" = None



class SetCookieBlockedReason(Enum):
    """Types of reasons why a cookie may not be stored from a response."""
    SECUREONLY = "SecureOnly"
    SAMESITESTRICT = "SameSiteStrict"
    SAMESITELAX = "SameSiteLax"
    SAMESITEUNSPECIFIEDTREATEDASLAX = "SameSiteUnspecifiedTreatedAsLax"
    SAMESITENONEINSECURE = "SameSiteNoneInsecure"
    USERPREFERENCES = "UserPreferences"
    THIRDPARTYPHASEOUT = "ThirdPartyPhaseout"
    THIRDPARTYBLOCKEDINFIRSTPARTYSET = "ThirdPartyBlockedInFirstPartySet"
    SYNTAXERROR = "SyntaxError"
    SCHEMENOTSUPPORTED = "SchemeNotSupported"
    OVERWRITESECURE = "OverwriteSecure"
    INVALIDDOMAIN = "InvalidDomain"
    INVALIDPREFIX = "InvalidPrefix"
    UNKNOWNERROR = "UnknownError"
    SCHEMEFULSAMESITESTRICT = "SchemefulSameSiteStrict"
    SCHEMEFULSAMESITELAX = "SchemefulSameSiteLax"
    SCHEMEFULSAMESITEUNSPECIFIEDTREATEDASLAX = "SchemefulSameSiteUnspecifiedTreatedAsLax"
    SAMEPARTYFROMCROSSPARTYCONTEXT = "SamePartyFromCrossPartyContext"
    SAMEPARTYCONFLICTSWITHOTHERATTRIBUTES = "SamePartyConflictsWithOtherAttributes"
    NAMEVALUEPAIREXCEEDSMAXSIZE = "NameValuePairExceedsMaxSize"
    DISALLOWEDCHARACTER = "DisallowedCharacter"
    NOCOOKIECONTENT = "NoCookieContent"



class CookieBlockedReason(Enum):
    """Types of reasons why a cookie may not be sent with a request."""
    SECUREONLY = "SecureOnly"
    NOTONPATH = "NotOnPath"
    DOMAINMISMATCH = "DomainMismatch"
    SAMESITESTRICT = "SameSiteStrict"
    SAMESITELAX = "SameSiteLax"
    SAMESITEUNSPECIFIEDTREATEDASLAX = "SameSiteUnspecifiedTreatedAsLax"
    SAMESITENONEINSECURE = "SameSiteNoneInsecure"
    USERPREFERENCES = "UserPreferences"
    THIRDPARTYPHASEOUT = "ThirdPartyPhaseout"
    THIRDPARTYBLOCKEDINFIRSTPARTYSET = "ThirdPartyBlockedInFirstPartySet"
    UNKNOWNERROR = "UnknownError"
    SCHEMEFULSAMESITESTRICT = "SchemefulSameSiteStrict"
    SCHEMEFULSAMESITELAX = "SchemefulSameSiteLax"
    SCHEMEFULSAMESITEUNSPECIFIEDTREATEDASLAX = "SchemefulSameSiteUnspecifiedTreatedAsLax"
    SAMEPARTYFROMCROSSPARTYCONTEXT = "SamePartyFromCrossPartyContext"
    NAMEVALUEPAIREXCEEDSMAXSIZE = "NameValuePairExceedsMaxSize"
    PORTMISMATCH = "PortMismatch"
    SCHEMEMISMATCH = "SchemeMismatch"
    ANONYMOUSCONTEXT = "AnonymousContext"



class CookieExemptionReason(Enum):
    """Types of reasons why a cookie should have been blocked by 3PCD but is exempted for the request."""
    NONE = "None"
    USERSETTING = "UserSetting"
    TPCDMETADATA = "TPCDMetadata"
    TPCDDEPRECATIONTRIAL = "TPCDDeprecationTrial"
    TOPLEVELTPCDDEPRECATIONTRIAL = "TopLevelTPCDDeprecationTrial"
    TPCDHEURISTICS = "TPCDHeuristics"
    ENTERPRISEPOLICY = "EnterprisePolicy"
    STORAGEACCESS = "StorageAccess"
    TOPLEVELSTORAGEACCESS = "TopLevelStorageAccess"
    SCHEME = "Scheme"
    SAMESITENONECOOKIESINSANDBOX = "SameSiteNoneCookiesInSandbox"



class BlockedSetCookieWithReason(BaseModel):
    """A cookie which was not stored from a response with the corresponding reason."""
    blockedReasons: "List[Union[SetCookieBlockedReason, str]]"
    cookieLine: "str"
    cookie: "Optional[Cookie]" = None



class ExemptedSetCookieWithReason(BaseModel):
    """A cookie should have been blocked by 3PCD but is exempted and stored from a response with the
corresponding reason. A cookie could only have at most one exemption reason."""
    exemptionReason: "Union[CookieExemptionReason, str]"
    cookieLine: "str"
    cookie: "Cookie"



class AssociatedCookie(BaseModel):
    """A cookie associated with the request which may or may not be sent with it.
Includes the cookies itself and reasons for blocking or exemption."""
    cookie: "Cookie"
    blockedReasons: "List[Union[CookieBlockedReason, str]]"
    exemptionReason: "Optional[Union[CookieExemptionReason, str]]" = None



class CookieParam(BaseModel):
    """Cookie parameter object"""
    name: "str"
    value: "str"
    url: "Optional[str]" = None
    domain: "Optional[str]" = None
    path: "Optional[str]" = None
    secure: "Optional[bool]" = None
    httpOnly: "Optional[bool]" = None
    sameSite: "Optional[Union[CookieSameSite, str]]" = None
    expires: "Optional[TimeSinceEpoch]" = None
    priority: "Optional[Union[CookiePriority, str]]" = None
    sameParty: "Optional[bool]" = None
    sourceScheme: "Optional[Union[CookieSourceScheme, str]]" = None
    sourcePort: "Optional[int]" = None
    partitionKey: "Optional[CookiePartitionKey]" = None



class AuthChallenge(BaseModel):
    """Authorization challenge for HTTP status code 401 or 407."""
    origin: "str"
    scheme: "str"
    realm: "str"
    source: "Optional[str]" = None



class AuthChallengeResponse(BaseModel):
    """Response to an AuthChallenge."""
    response: "str"
    username: "Optional[str]" = None
    password: "Optional[str]" = None



class InterceptionStage(Enum):
    """Stages of the interception to begin intercepting. Request will intercept before the request is
sent. Response will intercept after the response is received."""
    REQUEST = "Request"
    HEADERSRECEIVED = "HeadersReceived"



class RequestPattern(BaseModel):
    """Request pattern for interception."""
    urlPattern: "Optional[str]" = None
    resourceType: "Optional[Union[ResourceType, str]]" = None
    interceptionStage: "Optional[Union[InterceptionStage, str]]" = None



class SignedExchangeSignature(BaseModel):
    """Information about a signed exchange signature.
https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.3.1"""
    label: "str"
    signature: "str"
    integrity: "str"
    validityUrl: "str"
    date: "int"
    expires: "int"
    certUrl: "Optional[str]" = None
    certSha256: "Optional[str]" = None
    certificates: "Optional[List[str]]" = None



class SignedExchangeHeader(BaseModel):
    """Information about a signed exchange header.
https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation"""
    requestUrl: "str"
    responseCode: "int"
    responseHeaders: "Headers"
    signatures: "List[SignedExchangeSignature]"
    headerIntegrity: "str"



class SignedExchangeErrorField(Enum):
    """Field type for a signed exchange related error."""
    SIGNATURESIG = "signatureSig"
    SIGNATUREINTEGRITY = "signatureIntegrity"
    SIGNATURECERTURL = "signatureCertUrl"
    SIGNATURECERTSHA256 = "signatureCertSha256"
    SIGNATUREVALIDITYURL = "signatureValidityUrl"
    SIGNATURETIMESTAMPS = "signatureTimestamps"



class SignedExchangeError(BaseModel):
    """Information about a signed exchange response."""
    message: "str"
    signatureIndex: "Optional[int]" = None
    errorField: "Optional[Union[SignedExchangeErrorField, str]]" = None



class SignedExchangeInfo(BaseModel):
    """Information about a signed exchange response."""
    outerResponse: "Response"
    hasExtraInfo: "bool"
    header: "Optional[SignedExchangeHeader]" = None
    securityDetails: "Optional[SecurityDetails]" = None
    errors: "Optional[List[SignedExchangeError]]" = None



class ContentEncoding(Enum):
    """List of content encodings supported by the backend."""
    DEFLATE = "deflate"
    GZIP = "gzip"
    BR = "br"
    ZSTD = "zstd"



class DirectSocketDnsQueryType(Enum):
    IPV4 = "ipv4"
    IPV6 = "ipv6"



class DirectTCPSocketOptions(BaseModel):
    noDelay: "bool"
    keepAliveDelay: "Optional[float]" = None
    sendBufferSize: "Optional[float]" = None
    receiveBufferSize: "Optional[float]" = None
    dnsQueryType: "Optional[Union[DirectSocketDnsQueryType, str]]" = None



class DirectUDPSocketOptions(BaseModel):
    remoteAddr: "Optional[str]" = None
    remotePort: "Optional[int]" = None
    localAddr: "Optional[str]" = None
    localPort: "Optional[int]" = None
    dnsQueryType: "Optional[Union[DirectSocketDnsQueryType, str]]" = None
    sendBufferSize: "Optional[float]" = None
    receiveBufferSize: "Optional[float]" = None



class DirectUDPMessage(BaseModel):
    data: "str"
    remoteAddr: "Optional[str]" = None
    remotePort: "Optional[int]" = None



class PrivateNetworkRequestPolicy(Enum):
    ALLOW = "Allow"
    BLOCKFROMINSECURETOMOREPRIVATE = "BlockFromInsecureToMorePrivate"
    WARNFROMINSECURETOMOREPRIVATE = "WarnFromInsecureToMorePrivate"
    PREFLIGHTBLOCK = "PreflightBlock"
    PREFLIGHTWARN = "PreflightWarn"
    PERMISSIONBLOCK = "PermissionBlock"
    PERMISSIONWARN = "PermissionWarn"



class IPAddressSpace(Enum):
    LOOPBACK = "Loopback"
    PRIVATE = "Private"
    PUBLIC = "Public"
    UNKNOWN = "Unknown"



class ConnectTiming(BaseModel):
    requestTime: "float"



class ClientSecurityState(BaseModel):
    initiatorIsSecureContext: "bool"
    initiatorIPAddressSpace: "Union[IPAddressSpace, str]"
    privateNetworkRequestPolicy: "Union[PrivateNetworkRequestPolicy, str]"



class CrossOriginOpenerPolicyValue(Enum):
    SAMEORIGIN = "SameOrigin"
    SAMEORIGINALLOWPOPUPS = "SameOriginAllowPopups"
    RESTRICTPROPERTIES = "RestrictProperties"
    UNSAFENONE = "UnsafeNone"
    SAMEORIGINPLUSCOEP = "SameOriginPlusCoep"
    RESTRICTPROPERTIESPLUSCOEP = "RestrictPropertiesPlusCoep"
    NOOPENERALLOWPOPUPS = "NoopenerAllowPopups"



class CrossOriginOpenerPolicyStatus(BaseModel):
    value: "Union[CrossOriginOpenerPolicyValue, str]"
    reportOnlyValue: "Union[CrossOriginOpenerPolicyValue, str]"
    reportingEndpoint: "Optional[str]" = None
    reportOnlyReportingEndpoint: "Optional[str]" = None



class CrossOriginEmbedderPolicyValue(Enum):
    NONE = "None"
    CREDENTIALLESS = "Credentialless"
    REQUIRECORP = "RequireCorp"



class CrossOriginEmbedderPolicyStatus(BaseModel):
    value: "Union[CrossOriginEmbedderPolicyValue, str]"
    reportOnlyValue: "Union[CrossOriginEmbedderPolicyValue, str]"
    reportingEndpoint: "Optional[str]" = None
    reportOnlyReportingEndpoint: "Optional[str]" = None



class ContentSecurityPolicySource(Enum):
    HTTP = "HTTP"
    META = "Meta"



class ContentSecurityPolicyStatus(BaseModel):
    effectiveDirectives: "str"
    isEnforced: "bool"
    source: "Union[ContentSecurityPolicySource, str]"



class SecurityIsolationStatus(BaseModel):
    coop: "Optional[CrossOriginOpenerPolicyStatus]" = None
    coep: "Optional[CrossOriginEmbedderPolicyStatus]" = None
    csp: "Optional[List[ContentSecurityPolicyStatus]]" = None



class ReportStatus(Enum):
    """The status of a Reporting API report."""
    QUEUED = "Queued"
    PENDING = "Pending"
    MARKEDFORREMOVAL = "MarkedForRemoval"
    SUCCESS = "Success"



ReportId = str



class ReportingApiReport(BaseModel):
    """An object representing a report generated by the Reporting API."""
    id: "ReportId"
    initiatorUrl: "str"
    destination: "str"
    type: "str"
    timestamp: "TimeSinceEpoch"
    depth: "int"
    completedAttempts: "int"
    body: "Dict[str, Any]"
    status: "Union[ReportStatus, str]"



class ReportingApiEndpoint(BaseModel):
    url: "str"
    groupName: "str"



class LoadNetworkResourcePageResult(BaseModel):
    """An object providing the result of a network resource load."""
    success: "bool"
    netError: "Optional[float]" = None
    netErrorName: "Optional[str]" = None
    httpStatusCode: "Optional[float]" = None
    stream: "Optional[StreamHandle]" = None
    headers: "Optional[Headers]" = None



class LoadNetworkResourceOptions(BaseModel):
    """An options object that may be extended later to better support CORS,
CORB and streaming."""
    disableCache: "bool"
    includeCredentials: "bool"


# Rebuild Pydantic models to resolve forward references
# Import dependencies for model rebuilding
def _rebuild_models_when_ready():
    try:
        from ..io.types import StreamHandle
        from ..runtime.types import StackTrace
        from ..security.types import CertificateId
        from ..security.types import MixedContentType
        from ..security.types import SecurityState
        # Rebuild models now that imports are available
        Headers.model_rebuild()
        ResourceTiming.model_rebuild()
        PostDataEntry.model_rebuild()
        Request.model_rebuild()
        SignedCertificateTimestamp.model_rebuild()
        SecurityDetails.model_rebuild()
        CorsErrorStatus.model_rebuild()
        TrustTokenParams.model_rebuild()
        ServiceWorkerRouterInfo.model_rebuild()
        Response.model_rebuild()
        WebSocketRequest.model_rebuild()
        WebSocketResponse.model_rebuild()
        WebSocketFrame.model_rebuild()
        CachedResource.model_rebuild()
        Initiator.model_rebuild()
        CookiePartitionKey.model_rebuild()
        Cookie.model_rebuild()
        BlockedSetCookieWithReason.model_rebuild()
        ExemptedSetCookieWithReason.model_rebuild()
        AssociatedCookie.model_rebuild()
        CookieParam.model_rebuild()
        AuthChallenge.model_rebuild()
        AuthChallengeResponse.model_rebuild()
        RequestPattern.model_rebuild()
        SignedExchangeSignature.model_rebuild()
        SignedExchangeHeader.model_rebuild()
        SignedExchangeError.model_rebuild()
        SignedExchangeInfo.model_rebuild()
        DirectTCPSocketOptions.model_rebuild()
        DirectUDPSocketOptions.model_rebuild()
        DirectUDPMessage.model_rebuild()
        ConnectTiming.model_rebuild()
        ClientSecurityState.model_rebuild()
        CrossOriginOpenerPolicyStatus.model_rebuild()
        CrossOriginEmbedderPolicyStatus.model_rebuild()
        ContentSecurityPolicyStatus.model_rebuild()
        SecurityIsolationStatus.model_rebuild()
        ReportingApiReport.model_rebuild()
        ReportingApiEndpoint.model_rebuild()
        LoadNetworkResourcePageResult.model_rebuild()
        LoadNetworkResourceOptions.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
