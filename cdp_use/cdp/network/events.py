# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Network Domain Events"""

from pydantic import BaseModel
from typing import List, Optional, Union

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..page.types import FrameId
    from .types import AssociatedCookie
    from .types import AuthChallenge
    from .types import BlockedReason
    from .types import BlockedSetCookieWithReason
    from .types import ClientSecurityState
    from .types import ConnectTiming
    from .types import CookiePartitionKey
    from .types import CorsErrorStatus
    from .types import DirectTCPSocketOptions
    from .types import DirectUDPMessage
    from .types import DirectUDPSocketOptions
    from .types import ErrorReason
    from .types import ExemptedSetCookieWithReason
    from .types import Headers
    from .types import IPAddressSpace
    from .types import Initiator
    from .types import InterceptionId
    from .types import LoaderId
    from .types import MonotonicTime
    from .types import ReportingApiEndpoint
    from .types import ReportingApiReport
    from .types import Request
    from .types import RequestId
    from .types import ResourcePriority
    from .types import ResourceType
    from .types import Response
    from .types import SignedExchangeInfo
    from .types import TimeSinceEpoch
    from .types import TrustTokenOperationType
    from .types import WebSocketFrame
    from .types import WebSocketRequest
    from .types import WebSocketResponse

class DataReceivedEvent(BaseModel):
    """Fired when data chunk was received over the network."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    dataLength: "int"
    encodedDataLength: "int"
    data: "Optional[str]" = None



class EventSourceMessageReceivedEvent(BaseModel):
    """Fired when EventSource message is received."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    eventName: "str"
    eventId: "str"
    data: "str"



class LoadingFailedEvent(BaseModel):
    """Fired when HTTP request has failed to load."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    type: "Union[ResourceType, str]"
    errorText: "str"
    canceled: "Optional[bool]" = None
    blockedReason: "Optional[Union[BlockedReason, str]]" = None
    corsErrorStatus: "Optional[CorsErrorStatus]" = None



class LoadingFinishedEvent(BaseModel):
    """Fired when HTTP request has finished loading."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    encodedDataLength: "float"



class RequestInterceptedEvent(BaseModel):
    """Details of an intercepted HTTP request, which must be either allowed, blocked, modified or
mocked.
Deprecated, use Fetch.requestPaused instead."""
    interceptionId: "InterceptionId"
    request: "Request"
    frameId: "FrameId"
    resourceType: "Union[ResourceType, str]"
    isNavigationRequest: "bool"
    isDownload: "Optional[bool]" = None
    redirectUrl: "Optional[str]" = None
    authChallenge: "Optional[AuthChallenge]" = None
    responseErrorReason: "Optional[Union[ErrorReason, str]]" = None
    responseStatusCode: "Optional[int]" = None
    responseHeaders: "Optional[Headers]" = None
    requestId: "Optional[RequestId]" = None



class RequestServedFromCacheEvent(BaseModel):
    """Fired if request ended up loading from cache."""
    requestId: "RequestId"



class RequestWillBeSentEvent(BaseModel):
    """Fired when page is about to send HTTP request."""
    requestId: "RequestId"
    loaderId: "LoaderId"
    documentURL: "str"
    request: "Request"
    timestamp: "MonotonicTime"
    wallTime: "TimeSinceEpoch"
    initiator: "Initiator"
    redirectHasExtraInfo: "bool"
    redirectResponse: "Optional[Response]" = None
    type: "Optional[Union[ResourceType, str]]" = None
    frameId: "Optional[FrameId]" = None
    hasUserGesture: "Optional[bool]" = None



class ResourceChangedPriorityEvent(BaseModel):
    """Fired when resource loading priority is changed"""
    requestId: "RequestId"
    newPriority: "Union[ResourcePriority, str]"
    timestamp: "MonotonicTime"



class SignedExchangeReceivedEvent(BaseModel):
    """Fired when a signed exchange was received over the network"""
    requestId: "RequestId"
    info: "SignedExchangeInfo"



class ResponseReceivedEvent(BaseModel):
    """Fired when HTTP response is available."""
    requestId: "RequestId"
    loaderId: "LoaderId"
    timestamp: "MonotonicTime"
    type: "Union[ResourceType, str]"
    response: "Response"
    hasExtraInfo: "bool"
    frameId: "Optional[FrameId]" = None



class WebSocketClosedEvent(BaseModel):
    """Fired when WebSocket is closed."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"



class WebSocketCreatedEvent(BaseModel):
    """Fired upon WebSocket creation."""
    requestId: "RequestId"
    url: "str"
    initiator: "Optional[Initiator]" = None



class WebSocketFrameErrorEvent(BaseModel):
    """Fired when WebSocket message error occurs."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    errorMessage: "str"



class WebSocketFrameReceivedEvent(BaseModel):
    """Fired when WebSocket message is received."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    response: "WebSocketFrame"



class WebSocketFrameSentEvent(BaseModel):
    """Fired when WebSocket message is sent."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    response: "WebSocketFrame"



class WebSocketHandshakeResponseReceivedEvent(BaseModel):
    """Fired when WebSocket handshake response becomes available."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    response: "WebSocketResponse"



class WebSocketWillSendHandshakeRequestEvent(BaseModel):
    """Fired when WebSocket is about to initiate handshake."""
    requestId: "RequestId"
    timestamp: "MonotonicTime"
    wallTime: "TimeSinceEpoch"
    request: "WebSocketRequest"



class WebTransportCreatedEvent(BaseModel):
    """Fired upon WebTransport creation."""
    transportId: "RequestId"
    url: "str"
    timestamp: "MonotonicTime"
    initiator: "Optional[Initiator]" = None



class WebTransportConnectionEstablishedEvent(BaseModel):
    """Fired when WebTransport handshake is finished."""
    transportId: "RequestId"
    timestamp: "MonotonicTime"



class WebTransportClosedEvent(BaseModel):
    """Fired when WebTransport is disposed."""
    transportId: "RequestId"
    timestamp: "MonotonicTime"



class DirectTCPSocketCreatedEvent(BaseModel):
    """Fired upon direct_socket.TCPSocket creation."""
    identifier: "RequestId"
    remoteAddr: "str"
    remotePort: "int"
    options: "DirectTCPSocketOptions"
    timestamp: "MonotonicTime"
    initiator: "Optional[Initiator]" = None



class DirectTCPSocketOpenedEvent(BaseModel):
    """Fired when direct_socket.TCPSocket connection is opened."""
    identifier: "RequestId"
    remoteAddr: "str"
    remotePort: "int"
    timestamp: "MonotonicTime"
    localAddr: "Optional[str]" = None
    localPort: "Optional[int]" = None



class DirectTCPSocketAbortedEvent(BaseModel):
    """Fired when direct_socket.TCPSocket is aborted."""
    identifier: "RequestId"
    errorMessage: "str"
    timestamp: "MonotonicTime"



class DirectTCPSocketClosedEvent(BaseModel):
    """Fired when direct_socket.TCPSocket is closed."""
    identifier: "RequestId"
    timestamp: "MonotonicTime"



class DirectTCPSocketChunkSentEvent(BaseModel):
    """Fired when data is sent to tcp direct socket stream."""
    identifier: "RequestId"
    data: "str"
    timestamp: "MonotonicTime"



class DirectTCPSocketChunkReceivedEvent(BaseModel):
    """Fired when data is received from tcp direct socket stream."""
    identifier: "RequestId"
    data: "str"
    timestamp: "MonotonicTime"



class DirectUDPSocketCreatedEvent(BaseModel):
    """Fired upon direct_socket.UDPSocket creation."""
    identifier: "RequestId"
    options: "DirectUDPSocketOptions"
    timestamp: "MonotonicTime"
    initiator: "Optional[Initiator]" = None



class DirectUDPSocketOpenedEvent(BaseModel):
    """Fired when direct_socket.UDPSocket connection is opened."""
    identifier: "RequestId"
    localAddr: "str"
    localPort: "int"
    timestamp: "MonotonicTime"
    remoteAddr: "Optional[str]" = None
    remotePort: "Optional[int]" = None



class DirectUDPSocketAbortedEvent(BaseModel):
    """Fired when direct_socket.UDPSocket is aborted."""
    identifier: "RequestId"
    errorMessage: "str"
    timestamp: "MonotonicTime"



class DirectUDPSocketClosedEvent(BaseModel):
    """Fired when direct_socket.UDPSocket is closed."""
    identifier: "RequestId"
    timestamp: "MonotonicTime"



class DirectUDPSocketChunkSentEvent(BaseModel):
    """Fired when message is sent to udp direct socket stream."""
    identifier: "RequestId"
    message: "DirectUDPMessage"
    timestamp: "MonotonicTime"



class DirectUDPSocketChunkReceivedEvent(BaseModel):
    """Fired when message is received from udp direct socket stream."""
    identifier: "RequestId"
    message: "DirectUDPMessage"
    timestamp: "MonotonicTime"



class RequestWillBeSentExtraInfoEvent(BaseModel):
    """Fired when additional information about a requestWillBeSent event is available from the
network stack. Not every requestWillBeSent event will have an additional
requestWillBeSentExtraInfo fired for it, and there is no guarantee whether requestWillBeSent
or requestWillBeSentExtraInfo will be fired first for the same request."""
    requestId: "RequestId"
    associatedCookies: "List[AssociatedCookie]"
    headers: "Headers"
    connectTiming: "ConnectTiming"
    clientSecurityState: "Optional[ClientSecurityState]" = None
    siteHasCookieInOtherPartition: "Optional[bool]" = None



class ResponseReceivedExtraInfoEvent(BaseModel):
    """Fired when additional information about a responseReceived event is available from the network
stack. Not every responseReceived event will have an additional responseReceivedExtraInfo for
it, and responseReceivedExtraInfo may be fired before or after responseReceived."""
    requestId: "RequestId"
    blockedCookies: "List[BlockedSetCookieWithReason]"
    headers: "Headers"
    resourceIPAddressSpace: "Union[IPAddressSpace, str]"
    statusCode: "int"
    headersText: "Optional[str]" = None
    cookiePartitionKey: "Optional[CookiePartitionKey]" = None
    cookiePartitionKeyOpaque: "Optional[bool]" = None
    exemptedCookies: "Optional[List[ExemptedSetCookieWithReason]]" = None



class ResponseReceivedEarlyHintsEvent(BaseModel):
    """Fired when 103 Early Hints headers is received in addition to the common response.
Not every responseReceived event will have an responseReceivedEarlyHints fired.
Only one responseReceivedEarlyHints may be fired for eached responseReceived event."""
    requestId: "RequestId"
    headers: "Headers"



class TrustTokenOperationDoneEvent(BaseModel):
    """Fired exactly once for each Trust Token operation. Depending on
the type of the operation and whether the operation succeeded or
failed, the event is fired before the corresponding request was sent
or after the response was received."""
    status: "str"
    type: "Union[TrustTokenOperationType, str]"
    requestId: "RequestId"
    topLevelOrigin: "Optional[str]" = None
    issuerOrigin: "Optional[str]" = None
    issuedTokenCount: "Optional[int]" = None



class PolicyUpdatedEvent(BaseModel):
    """Fired once security policy has been updated."""
    pass



class SubresourceWebBundleMetadataReceivedEvent(BaseModel):
    """Fired once when parsing the .wbn file has succeeded.
The event contains the information about the web bundle contents."""
    requestId: "RequestId"
    urls: "List[str]"



class SubresourceWebBundleMetadataErrorEvent(BaseModel):
    """Fired once when parsing the .wbn file has failed."""
    requestId: "RequestId"
    errorMessage: "str"



class SubresourceWebBundleInnerResponseParsedEvent(BaseModel):
    """Fired when handling requests for resources within a .wbn file.
Note: this will only be fired for resources that are requested by the webpage."""
    innerRequestId: "RequestId"
    innerRequestURL: "str"
    bundleRequestId: "Optional[RequestId]" = None



class SubresourceWebBundleInnerResponseErrorEvent(BaseModel):
    """Fired when request for resources within a .wbn file failed."""
    innerRequestId: "RequestId"
    innerRequestURL: "str"
    errorMessage: "str"
    bundleRequestId: "Optional[RequestId]" = None



class ReportingApiReportAddedEvent(BaseModel):
    """Is sent whenever a new report is added.
And after 'enableReportingApi' for all existing reports."""
    report: "ReportingApiReport"



class ReportingApiReportUpdatedEvent(BaseModel):
    report: "ReportingApiReport"



class ReportingApiEndpointsChangedForOriginEvent(BaseModel):
    origin: "str"
    endpoints: "List[ReportingApiEndpoint]"


# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..page.types import FrameId
        from .types import AssociatedCookie
        from .types import AuthChallenge
        from .types import BlockedReason
        from .types import BlockedSetCookieWithReason
        from .types import ClientSecurityState
        from .types import ConnectTiming
        from .types import CookiePartitionKey
        from .types import CorsErrorStatus
        from .types import DirectTCPSocketOptions
        from .types import DirectUDPMessage
        from .types import DirectUDPSocketOptions
        from .types import ErrorReason
        from .types import ExemptedSetCookieWithReason
        from .types import Headers
        from .types import IPAddressSpace
        from .types import Initiator
        from .types import InterceptionId
        from .types import LoaderId
        from .types import MonotonicTime
        from .types import ReportingApiEndpoint
        from .types import ReportingApiReport
        from .types import Request
        from .types import RequestId
        from .types import ResourcePriority
        from .types import ResourceType
        from .types import Response
        from .types import SignedExchangeInfo
        from .types import TimeSinceEpoch
        from .types import TrustTokenOperationType
        from .types import WebSocketFrame
        from .types import WebSocketRequest
        from .types import WebSocketResponse
        # Rebuild models now that imports are available
        DataReceivedEvent.model_rebuild()
        EventSourceMessageReceivedEvent.model_rebuild()
        LoadingFailedEvent.model_rebuild()
        LoadingFinishedEvent.model_rebuild()
        RequestInterceptedEvent.model_rebuild()
        RequestServedFromCacheEvent.model_rebuild()
        RequestWillBeSentEvent.model_rebuild()
        ResourceChangedPriorityEvent.model_rebuild()
        SignedExchangeReceivedEvent.model_rebuild()
        ResponseReceivedEvent.model_rebuild()
        WebSocketClosedEvent.model_rebuild()
        WebSocketCreatedEvent.model_rebuild()
        WebSocketFrameErrorEvent.model_rebuild()
        WebSocketFrameReceivedEvent.model_rebuild()
        WebSocketFrameSentEvent.model_rebuild()
        WebSocketHandshakeResponseReceivedEvent.model_rebuild()
        WebSocketWillSendHandshakeRequestEvent.model_rebuild()
        WebTransportCreatedEvent.model_rebuild()
        WebTransportConnectionEstablishedEvent.model_rebuild()
        WebTransportClosedEvent.model_rebuild()
        DirectTCPSocketCreatedEvent.model_rebuild()
        DirectTCPSocketOpenedEvent.model_rebuild()
        DirectTCPSocketAbortedEvent.model_rebuild()
        DirectTCPSocketClosedEvent.model_rebuild()
        DirectTCPSocketChunkSentEvent.model_rebuild()
        DirectTCPSocketChunkReceivedEvent.model_rebuild()
        DirectUDPSocketCreatedEvent.model_rebuild()
        DirectUDPSocketOpenedEvent.model_rebuild()
        DirectUDPSocketAbortedEvent.model_rebuild()
        DirectUDPSocketClosedEvent.model_rebuild()
        DirectUDPSocketChunkSentEvent.model_rebuild()
        DirectUDPSocketChunkReceivedEvent.model_rebuild()
        RequestWillBeSentExtraInfoEvent.model_rebuild()
        ResponseReceivedExtraInfoEvent.model_rebuild()
        ResponseReceivedEarlyHintsEvent.model_rebuild()
        TrustTokenOperationDoneEvent.model_rebuild()
        PolicyUpdatedEvent.model_rebuild()
        SubresourceWebBundleMetadataReceivedEvent.model_rebuild()
        SubresourceWebBundleMetadataErrorEvent.model_rebuild()
        SubresourceWebBundleInnerResponseParsedEvent.model_rebuild()
        SubresourceWebBundleInnerResponseErrorEvent.model_rebuild()
        ReportingApiReportAddedEvent.model_rebuild()
        ReportingApiReportUpdatedEvent.model_rebuild()
        ReportingApiEndpointsChangedForOriginEvent.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
