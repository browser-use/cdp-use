# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Network Domain Commands"""

from pydantic import BaseModel
from typing import List, Optional
from typing_extensions import TypedDict

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..debugger.types import SearchMatch
    from ..emulation.types import UserAgentMetadata
    from ..io.types import StreamHandle
    from ..page.types import FrameId
    from .types import AuthChallengeResponse
    from .types import ConnectionType
    from .types import ContentEncoding
    from .types import Cookie
    from .types import CookieParam
    from .types import CookiePartitionKey
    from .types import CookiePriority
    from .types import CookieSameSite
    from .types import CookieSourceScheme
    from .types import ErrorReason
    from .types import Headers
    from .types import InterceptionId
    from .types import LoadNetworkResourceOptions
    from .types import LoadNetworkResourcePageResult
    from .types import RequestId
    from .types import RequestPattern
    from .types import SecurityIsolationStatus
    from .types import TimeSinceEpoch

class SetAcceptedEncodingsParameters(TypedDict):
    encodings: "List[ContentEncoding]"
    """List of accepted content encodings."""





class CanClearBrowserCacheReturns(BaseModel):
    result: "bool"



class CanClearBrowserCookiesReturns(BaseModel):
    result: "bool"



class CanEmulateNetworkConditionsReturns(BaseModel):
    result: "bool"



class ContinueInterceptedRequestParameters(TypedDict):
    interceptionId: "InterceptionId"
    errorReason: "Optional[ErrorReason]"
    """If set this causes the request to fail with the given reason. Passing `Aborted` for requests
marked with `isNavigationRequest` also cancels the navigation. Must not be set in response
to an authChallenge."""
    rawResponse: "Optional[str]"
    """If set the requests completes using with the provided base64 encoded raw response, including
HTTP status line and headers etc... Must not be set in response to an authChallenge. (Encoded as a base64 string when passed over JSON)"""
    url: "Optional[str]"
    """If set the request url will be modified in a way that's not observable by page. Must not be
set in response to an authChallenge."""
    method: "Optional[str]"
    """If set this allows the request method to be overridden. Must not be set in response to an
authChallenge."""
    postData: "Optional[str]"
    """If set this allows postData to be set. Must not be set in response to an authChallenge."""
    headers: "Optional[Headers]"
    """If set this allows the request headers to be changed. Must not be set in response to an
authChallenge."""
    authChallengeResponse: "Optional[AuthChallengeResponse]"
    """Response to a requestIntercepted with an authChallenge. Must not be set otherwise."""





class DeleteCookiesParameters(TypedDict):
    name: "str"
    """Name of the cookies to remove."""
    url: "Optional[str]"
    """If specified, deletes all the cookies with the given name where domain and path match
provided URL."""
    domain: "Optional[str]"
    """If specified, deletes only cookies with the exact domain."""
    path: "Optional[str]"
    """If specified, deletes only cookies with the exact path."""
    partitionKey: "Optional[CookiePartitionKey]"
    """If specified, deletes only cookies with the the given name and partitionKey where
all partition key attributes match the cookie partition key attribute."""





class EmulateNetworkConditionsParameters(TypedDict):
    offline: "bool"
    """True to emulate internet disconnection."""
    latency: "float"
    """Minimum latency from request sent to response headers received (ms)."""
    downloadThroughput: "float"
    """Maximal aggregated download throughput (bytes/sec). -1 disables download throttling."""
    uploadThroughput: "float"
    """Maximal aggregated upload throughput (bytes/sec).  -1 disables upload throttling."""
    connectionType: "Optional[ConnectionType]"
    """Connection type if known."""
    packetLoss: "Optional[float]"
    """WebRTC packet loss (percent, 0-100). 0 disables packet loss emulation, 100 drops all the packets."""
    packetQueueLength: "Optional[int]"
    """WebRTC packet queue length (packet). 0 removes any queue length limitations."""
    packetReordering: "Optional[bool]"
    """WebRTC packetReordering feature."""





class EnableParameters(TypedDict, total=False):
    maxTotalBufferSize: "int"
    """Buffer size in bytes to use when preserving network payloads (XHRs, etc)."""
    maxResourceBufferSize: "int"
    """Per-resource buffer size in bytes to use when preserving network payloads (XHRs, etc)."""
    maxPostDataSize: "int"
    """Longest post body size (in bytes) that would be included in requestWillBeSent notification"""
    reportDirectSocketTraffic: "bool"
    """Whether DirectSocket chunk send/receive events should be reported."""





class GetAllCookiesReturns(BaseModel):
    cookies: "List[Cookie]"



class GetCertificateParameters(TypedDict):
    origin: "str"
    """Origin to get certificate for."""


class GetCertificateReturns(BaseModel):
    tableNames: "List[str]"



class GetCookiesParameters(TypedDict, total=False):
    urls: "List[str]"
    """The list of URLs for which applicable cookies will be fetched.
If not specified, it's assumed to be set to the list containing
the URLs of the page and all of its subframes."""


class GetCookiesReturns(BaseModel):
    cookies: "List[Cookie]"



class GetResponseBodyParameters(TypedDict):
    requestId: "RequestId"
    """Identifier of the network request to get content for."""


class GetResponseBodyReturns(BaseModel):
    body: "str"
    base64Encoded: "bool"



class GetRequestPostDataParameters(TypedDict):
    requestId: "RequestId"
    """Identifier of the network request to get content for."""


class GetRequestPostDataReturns(BaseModel):
    postData: "str"



class GetResponseBodyForInterceptionParameters(TypedDict):
    interceptionId: "InterceptionId"
    """Identifier for the intercepted request to get body for."""


class GetResponseBodyForInterceptionReturns(BaseModel):
    body: "str"
    base64Encoded: "bool"



class TakeResponseBodyForInterceptionAsStreamParameters(TypedDict):
    interceptionId: "InterceptionId"


class TakeResponseBodyForInterceptionAsStreamReturns(BaseModel):
    stream: "StreamHandle"



class ReplayXHRParameters(TypedDict):
    requestId: "RequestId"
    """Identifier of XHR to replay."""





class SearchInResponseBodyParameters(TypedDict):
    requestId: "RequestId"
    """Identifier of the network response to search."""
    query: "str"
    """String to search for."""
    caseSensitive: "Optional[bool]"
    """If true, search is case sensitive."""
    isRegex: "Optional[bool]"
    """If true, treats string parameter as regex."""


class SearchInResponseBodyReturns(BaseModel):
    result: "List[SearchMatch]"



class SetBlockedURLsParameters(TypedDict):
    urls: "List[str]"
    """URL patterns to block. Wildcards ('*') are allowed."""





class SetBypassServiceWorkerParameters(TypedDict):
    bypass: "bool"
    """Bypass service worker and load from network."""





class SetCacheDisabledParameters(TypedDict):
    cacheDisabled: "bool"
    """Cache disabled state."""





class SetCookieParameters(TypedDict):
    name: "str"
    """Cookie name."""
    value: "str"
    """Cookie value."""
    url: "Optional[str]"
    """The request-URI to associate with the setting of the cookie. This value can affect the
default domain, path, source port, and source scheme values of the created cookie."""
    domain: "Optional[str]"
    """Cookie domain."""
    path: "Optional[str]"
    """Cookie path."""
    secure: "Optional[bool]"
    """True if cookie is secure."""
    httpOnly: "Optional[bool]"
    """True if cookie is http-only."""
    sameSite: "Optional[CookieSameSite]"
    """Cookie SameSite type."""
    expires: "Optional[TimeSinceEpoch]"
    """Cookie expiration date, session cookie if not set"""
    priority: "Optional[CookiePriority]"
    """Cookie Priority type."""
    sameParty: "Optional[bool]"
    """True if cookie is SameParty."""
    sourceScheme: "Optional[CookieSourceScheme]"
    """Cookie source scheme type."""
    sourcePort: "Optional[int]"
    """Cookie source port. Valid values are {-1, [1, 65535]}, -1 indicates an unspecified port.
An unspecified port value allows protocol clients to emulate legacy cookie scope for the port.
This is a temporary ability and it will be removed in the future."""
    partitionKey: "Optional[CookiePartitionKey]"
    """Cookie partition key. If not set, the cookie will be set as not partitioned."""


class SetCookieReturns(BaseModel):
    success: "bool"



class SetCookiesParameters(TypedDict):
    cookies: "List[CookieParam]"
    """Cookies to be set."""





class SetExtraHTTPHeadersParameters(TypedDict):
    headers: "Headers"
    """Map with extra HTTP headers."""





class SetAttachDebugStackParameters(TypedDict):
    enabled: "bool"
    """Whether to attach a page script stack for debugging purpose."""





class SetRequestInterceptionParameters(TypedDict):
    patterns: "List[RequestPattern]"
    """Requests matching any of these patterns will be forwarded and wait for the corresponding
continueInterceptedRequest call."""





class SetUserAgentOverrideParameters(TypedDict):
    userAgent: "str"
    """User agent to use."""
    acceptLanguage: "Optional[str]"
    """Browser language to emulate."""
    platform: "Optional[str]"
    """The platform navigator.platform should return."""
    userAgentMetadata: "Optional[UserAgentMetadata]"
    """To be sent in Sec-CH-UA-* headers and returned in navigator.userAgentData"""





class StreamResourceContentParameters(TypedDict):
    requestId: "RequestId"
    """Identifier of the request to stream."""


class StreamResourceContentReturns(BaseModel):
    bufferedData: "str"



class GetSecurityIsolationStatusParameters(TypedDict, total=False):
    frameId: "FrameId"
    """If no frameId is provided, the status of the target is provided."""


class GetSecurityIsolationStatusReturns(BaseModel):
    status: "SecurityIsolationStatus"



class EnableReportingApiParameters(TypedDict):
    enable: "bool"
    """Whether to enable or disable events for the Reporting API"""





class LoadNetworkResourceParameters(TypedDict):
    frameId: "Optional[FrameId]"
    """Frame id to get the resource for. Mandatory for frame targets, and
should be omitted for worker targets."""
    url: "str"
    """URL of the resource to get content for."""
    options: "LoadNetworkResourceOptions"
    """Options for the request."""


class LoadNetworkResourceReturns(BaseModel):
    resource: "LoadNetworkResourcePageResult"



class SetCookieControlsParameters(TypedDict):
    enableThirdPartyCookieRestriction: "bool"
    """Whether 3pc restriction is enabled."""
    disableThirdPartyCookieMetadata: "bool"
    """Whether 3pc grace period exception should be enabled; false by default."""
    disableThirdPartyCookieHeuristics: "bool"
    """Whether 3pc heuristics exceptions should be enabled; false by default."""




# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..debugger.types import SearchMatch
        from ..emulation.types import UserAgentMetadata
        from ..io.types import StreamHandle
        from ..page.types import FrameId
        from .types import AuthChallengeResponse
        from .types import ConnectionType
        from .types import ContentEncoding
        from .types import Cookie
        from .types import CookieParam
        from .types import CookiePartitionKey
        from .types import CookiePriority
        from .types import CookieSameSite
        from .types import CookieSourceScheme
        from .types import ErrorReason
        from .types import Headers
        from .types import InterceptionId
        from .types import LoadNetworkResourceOptions
        from .types import LoadNetworkResourcePageResult
        from .types import RequestId
        from .types import RequestPattern
        from .types import SecurityIsolationStatus
        from .types import TimeSinceEpoch
        # Rebuild models now that imports are available
        CanClearBrowserCacheReturns.model_rebuild()
        CanClearBrowserCookiesReturns.model_rebuild()
        CanEmulateNetworkConditionsReturns.model_rebuild()
        GetAllCookiesReturns.model_rebuild()
        GetCertificateReturns.model_rebuild()
        GetCookiesReturns.model_rebuild()
        GetResponseBodyReturns.model_rebuild()
        GetRequestPostDataReturns.model_rebuild()
        GetResponseBodyForInterceptionReturns.model_rebuild()
        TakeResponseBodyForInterceptionAsStreamReturns.model_rebuild()
        SearchInResponseBodyReturns.model_rebuild()
        SetCookieReturns.model_rebuild()
        StreamResourceContentReturns.model_rebuild()
        GetSecurityIsolationStatusReturns.model_rebuild()
        LoadNetworkResourceReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
