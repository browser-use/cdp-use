# This file is auto-generated by the CDP protocol generator.
# Do not edit this file manually as your changes will be overwritten.
# Generated from Chrome DevTools Protocol specifications.

"""CDP Network Domain Commands"""

from pydantic import BaseModel
from typing import List, Union
from typing_extensions import TypedDict, NotRequired

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from ..debugger.types import SearchMatch
    from ..emulation.types import UserAgentMetadata
    from ..io.types import StreamHandle
    from ..page.types import FrameId
    from .types import AuthChallengeResponse
    from .types import ConnectionType
    from .types import ContentEncoding
    from .types import Cookie
    from .types import CookieParam
    from .types import CookiePartitionKey
    from .types import CookiePriority
    from .types import CookieSameSite
    from .types import CookieSourceScheme
    from .types import ErrorReason
    from .types import Headers
    from .types import InterceptionId
    from .types import LoadNetworkResourceOptions
    from .types import LoadNetworkResourcePageResult
    from .types import RequestId
    from .types import RequestPattern
    from .types import SecurityIsolationStatus
    from .types import TimeSinceEpoch

class SetAcceptedEncodingsParameters(TypedDict):
    encodings: "List[Union[ContentEncoding, str]]"





class CanClearBrowserCacheReturns(BaseModel):
    result: "bool"



class CanClearBrowserCookiesReturns(BaseModel):
    result: "bool"



class CanEmulateNetworkConditionsReturns(BaseModel):
    result: "bool"



class ContinueInterceptedRequestParameters(TypedDict):
    interceptionId: "InterceptionId"
    errorReason: "NotRequired[Union[ErrorReason, str]]"
    rawResponse: "NotRequired[str]"
    url: "NotRequired[str]"
    method: "NotRequired[str]"
    postData: "NotRequired[str]"
    headers: "NotRequired[Headers]"
    authChallengeResponse: "NotRequired[AuthChallengeResponse]"





class DeleteCookiesParameters(TypedDict):
    name: "str"
    url: "NotRequired[str]"
    domain: "NotRequired[str]"
    path: "NotRequired[str]"
    partitionKey: "NotRequired[CookiePartitionKey]"





class EmulateNetworkConditionsParameters(TypedDict):
    offline: "bool"
    latency: "float"
    downloadThroughput: "float"
    uploadThroughput: "float"
    connectionType: "NotRequired[Union[ConnectionType, str]]"
    packetLoss: "NotRequired[float]"
    packetQueueLength: "NotRequired[int]"
    packetReordering: "NotRequired[bool]"





class EnableParameters(TypedDict, total=False):
    maxTotalBufferSize: "int"
    maxResourceBufferSize: "int"
    maxPostDataSize: "int"
    reportDirectSocketTraffic: "bool"





class GetAllCookiesReturns(BaseModel):
    cookies: "List[Cookie]"



class GetCertificateParameters(TypedDict):
    origin: "str"


class GetCertificateReturns(BaseModel):
    tableNames: "List[str]"



class GetCookiesParameters(TypedDict, total=False):
    urls: "List[str]"


class GetCookiesReturns(BaseModel):
    cookies: "List[Cookie]"



class GetResponseBodyParameters(TypedDict):
    requestId: "RequestId"


class GetResponseBodyReturns(BaseModel):
    body: "str"
    base64Encoded: "bool"



class GetRequestPostDataParameters(TypedDict):
    requestId: "RequestId"


class GetRequestPostDataReturns(BaseModel):
    postData: "str"



class GetResponseBodyForInterceptionParameters(TypedDict):
    interceptionId: "InterceptionId"


class GetResponseBodyForInterceptionReturns(BaseModel):
    body: "str"
    base64Encoded: "bool"



class TakeResponseBodyForInterceptionAsStreamParameters(TypedDict):
    interceptionId: "InterceptionId"


class TakeResponseBodyForInterceptionAsStreamReturns(BaseModel):
    stream: "StreamHandle"



class ReplayXHRParameters(TypedDict):
    requestId: "RequestId"





class SearchInResponseBodyParameters(TypedDict):
    requestId: "RequestId"
    query: "str"
    caseSensitive: "NotRequired[bool]"
    isRegex: "NotRequired[bool]"


class SearchInResponseBodyReturns(BaseModel):
    result: "List[SearchMatch]"



class SetBlockedURLsParameters(TypedDict):
    urls: "List[str]"





class SetBypassServiceWorkerParameters(TypedDict):
    bypass: "bool"





class SetCacheDisabledParameters(TypedDict):
    cacheDisabled: "bool"





class SetCookieParameters(TypedDict):
    name: "str"
    value: "str"
    url: "NotRequired[str]"
    domain: "NotRequired[str]"
    path: "NotRequired[str]"
    secure: "NotRequired[bool]"
    httpOnly: "NotRequired[bool]"
    sameSite: "NotRequired[Union[CookieSameSite, str]]"
    expires: "NotRequired[TimeSinceEpoch]"
    priority: "NotRequired[Union[CookiePriority, str]]"
    sameParty: "NotRequired[bool]"
    sourceScheme: "NotRequired[Union[CookieSourceScheme, str]]"
    sourcePort: "NotRequired[int]"
    partitionKey: "NotRequired[CookiePartitionKey]"


class SetCookieReturns(BaseModel):
    success: "bool"



class SetCookiesParameters(TypedDict):
    cookies: "List[CookieParam]"





class SetExtraHTTPHeadersParameters(TypedDict):
    headers: "Headers"





class SetAttachDebugStackParameters(TypedDict):
    enabled: "bool"





class SetRequestInterceptionParameters(TypedDict):
    patterns: "List[RequestPattern]"





class SetUserAgentOverrideParameters(TypedDict):
    userAgent: "str"
    acceptLanguage: "NotRequired[str]"
    platform: "NotRequired[str]"
    userAgentMetadata: "NotRequired[UserAgentMetadata]"





class StreamResourceContentParameters(TypedDict):
    requestId: "RequestId"


class StreamResourceContentReturns(BaseModel):
    bufferedData: "str"



class GetSecurityIsolationStatusParameters(TypedDict, total=False):
    frameId: "FrameId"


class GetSecurityIsolationStatusReturns(BaseModel):
    status: "SecurityIsolationStatus"



class EnableReportingApiParameters(TypedDict):
    enable: "bool"





class LoadNetworkResourceParameters(TypedDict):
    frameId: "NotRequired[FrameId]"
    url: "str"
    options: "LoadNetworkResourceOptions"


class LoadNetworkResourceReturns(BaseModel):
    resource: "LoadNetworkResourcePageResult"



class SetCookieControlsParameters(TypedDict):
    enableThirdPartyCookieRestriction: "bool"
    disableThirdPartyCookieMetadata: "bool"
    disableThirdPartyCookieHeuristics: "bool"




# Rebuild Pydantic models to resolve forward references
def _rebuild_models_when_ready():
    try:
        from ..debugger.types import SearchMatch
        from ..emulation.types import UserAgentMetadata
        from ..io.types import StreamHandle
        from ..page.types import FrameId
        from .types import AuthChallengeResponse
        from .types import ConnectionType
        from .types import ContentEncoding
        from .types import Cookie
        from .types import CookieParam
        from .types import CookiePartitionKey
        from .types import CookiePriority
        from .types import CookieSameSite
        from .types import CookieSourceScheme
        from .types import ErrorReason
        from .types import Headers
        from .types import InterceptionId
        from .types import LoadNetworkResourceOptions
        from .types import LoadNetworkResourcePageResult
        from .types import RequestId
        from .types import RequestPattern
        from .types import SecurityIsolationStatus
        from .types import TimeSinceEpoch
        # Rebuild models now that imports are available
        CanClearBrowserCacheReturns.model_rebuild()
        CanClearBrowserCookiesReturns.model_rebuild()
        CanEmulateNetworkConditionsReturns.model_rebuild()
        GetAllCookiesReturns.model_rebuild()
        GetCertificateReturns.model_rebuild()
        GetCookiesReturns.model_rebuild()
        GetResponseBodyReturns.model_rebuild()
        GetRequestPostDataReturns.model_rebuild()
        GetResponseBodyForInterceptionReturns.model_rebuild()
        TakeResponseBodyForInterceptionAsStreamReturns.model_rebuild()
        SearchInResponseBodyReturns.model_rebuild()
        SetCookieReturns.model_rebuild()
        StreamResourceContentReturns.model_rebuild()
        GetSecurityIsolationStatusReturns.model_rebuild()
        LoadNetworkResourceReturns.model_rebuild()
    except ImportError:
        pass  # Will be rebuilt later

_rebuild_models_when_ready()
